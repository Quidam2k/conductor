<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="description" content="Synchronized coordination for real-world actions. No server, no app store, no accounts.">
    <meta property="og:title" content="Conductor">
    <meta property="og:description" content="Synchronized coordination for real-world actions. No server, no app store, no accounts.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://quidam2k.github.io/conductor/">
    <meta property="og:image" content="https://quidam2k.github.io/conductor/icon-512.png">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Conductor">
    <meta name="twitter:description" content="Synchronized coordination for real-world actions. No server, no app store, no accounts.">
    <meta name="twitter:image" content="https://quidam2k.github.io/conductor/icon-512.png">
    <meta name="apple-mobile-web-app-title" content="Conductor">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>Conductor</title>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --bg: #1a1a2e;
            --bg-surface: #16213e;
            --bg-input: #0f1626;
            --text: #e0e0e0;
            --text-dim: rgba(255,255,255,0.45);
            --accent-blue: #4A9EFF;
            --accent-green: #34d399;
            --accent-red: #FF3B3B;
            --accent-gold: #FFD700;
            --radius: 10px;
        }

        html, body {
            height: 100vh;
            height: 100dvh;
            background: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* ─── Screen containers ─── */
        .screen {
            display: none;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            padding: 0;
        }
        .screen.active { display: flex; }

        /* ─── Header bar ─── */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            min-height: 52px;
            flex-shrink: 0;
        }
        .header h1 {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .header-input   { background: #0d1b3e; }
        .header-preview { background: #0d1b3e; }
        .header-practice { background: #0a2e1a; }
        .header-live     { background: #3b0a0a; }
        .header-done     { background: #0d1b3e; }

        .header .badge {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 3px 10px;
            border-radius: 4px;
        }
        .badge-practice { background: var(--accent-green); color: #000; }
        .badge-live     { background: var(--accent-red); color: #fff; animation: pulse-badge 1.2s ease-in-out infinite; }

        @keyframes pulse-badge {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* ─── Content area ─── */
        .content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        /* ─── Buttons ─── */
        button {
            font-family: inherit;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            min-height: 48px;
            padding: 12px 24px;
            transition: opacity 0.15s, transform 0.1s;
            -webkit-tap-highlight-color: transparent;
        }
        button:active { transform: scale(0.97); }

        .btn-primary {
            background: var(--accent-blue);
            color: #fff;
            width: 100%;
        }
        .btn-green {
            background: var(--accent-green);
            color: #000;
            width: 100%;
        }
        .btn-red {
            background: var(--accent-red);
            color: #fff;
            width: 100%;
        }
        .btn-outline {
            background: transparent;
            color: var(--text-dim);
            border: 1px solid rgba(255,255,255,0.15);
            width: 100%;
        }
        .btn-small {
            min-height: 40px;
            font-size: 14px;
            padding: 8px 16px;
            width: auto;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        .btn-row button { flex: 1; }

        /* ─── Input screen ─── */
        .app-logo {
            text-align: center;
            margin: 24px 0 8px;
        }
        .app-logo h2 {
            font-size: 28px;
            font-weight: 700;
            letter-spacing: 2px;
        }
        .app-logo p {
            color: var(--text-dim);
            font-size: 13px;
            margin-top: 4px;
        }
        .app-about {
            color: var(--text-dim);
            font-size: 13px;
            line-height: 1.5;
            text-align: center;
            margin: 0 8px 4px;
        }
        .app-about summary {
            cursor: pointer;
            font-size: 12px;
            color: var(--accent-blue);
            list-style: none;
            user-select: none;
        }
        .app-about summary::-webkit-details-marker { display: none; }
        .app-about .about-body {
            margin-top: 8px;
            text-align: left;
            padding: 0 4px;
        }
        .btn-hint {
            display: block;
            color: var(--text-dim);
            font-size: 11px;
            margin-top: 2px;
            text-align: center;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: var(--radius);
            padding: 12px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            margin: 12px 0;
        }
        textarea::placeholder { color: var(--text-dim); }
        textarea:focus { outline: none; border-color: var(--accent-blue); }

        .error-msg {
            color: var(--accent-red);
            font-size: 13px;
            margin: 6px 0;
            min-height: 20px;
        }

        .separator {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
            color: var(--text-dim);
            font-size: 12px;
        }
        .separator::before, .separator::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.1);
        }

        /* ─── Preview screen ─── */
        .event-info {
            background: var(--bg-surface);
            border-radius: var(--radius);
            padding: 16px;
            margin-bottom: 16px;
        }
        .event-info h2 {
            font-size: 20px;
            margin-bottom: 6px;
        }
        .event-info .desc {
            color: var(--text-dim);
            font-size: 14px;
            margin-bottom: 12px;
        }
        .event-meta {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 12px;
            font-size: 13px;
        }
        .event-meta dt { color: var(--text-dim); }
        .event-meta dd { color: var(--text); }

        .action-list {
            list-style: none;
            margin-top: 12px;
        }
        .action-list li {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            font-size: 14px;
        }
        .action-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .action-dot.normal   { background: var(--accent-blue); }
        .action-dot.emphasis { background: var(--accent-gold); }
        .action-dot.alert    { background: var(--accent-red); }
        .action-time {
            color: var(--text-dim);
            font-size: 12px;
            font-family: monospace;
            flex-shrink: 0;
            min-width: 48px;
        }

        /* ─── Practice / Live screens ─── */
        .canvas-wrap {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            padding: 8px;
        }
        .canvas-wrap canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            flex-shrink: 0;
            padding: 12px 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .speed-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .speed-row label {
            font-size: 13px;
            color: var(--text-dim);
            white-space: nowrap;
        }
        .speed-row input[type="range"] {
            flex: 1;
            accent-color: var(--accent-green);
            height: 28px;
        }
        .speed-val {
            font-size: 15px;
            font-weight: 700;
            font-family: monospace;
            min-width: 36px;
            text-align: right;
        }

        .icon-btn {
            min-height: 40px;
            min-width: 40px;
            padding: 6px;
            font-size: 20px;
            background: var(--bg-surface);
            border: 1px solid rgba(255,255,255,0.12);
            color: var(--text);
            border-radius: 8px;
        }
        .icon-btn.muted { opacity: 0.4; }

        /* ─── Completed screen ─── */
        .done-wrap {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 12px;
        }
        .done-wrap .check {
            font-size: 64px;
            line-height: 1;
        }
        .done-wrap h2 {
            font-size: 24px;
        }
        .done-wrap p {
            color: var(--text-dim);
            font-size: 14px;
        }

        /* ─── Editor screens ─── */
        .header-editor { background: #1a0d3e; }

        .field-label {
            display: block;
            font-size: 13px;
            color: var(--text-dim);
            margin-bottom: 4px;
            margin-top: 14px;
        }
        .field-label:first-of-type { margin-top: 0; }
        .field-input, .field-textarea, .field-select {
            width: 100%;
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: var(--radius);
            padding: 10px 12px;
            font-family: inherit;
            font-size: 15px;
        }
        .field-textarea { min-height: 70px; resize: vertical; font-size: 14px; }
        .field-input:focus, .field-textarea:focus, .field-select:focus {
            outline: none; border-color: var(--accent-blue);
        }
        .field-select { appearance: auto; }

        .ed-action-list { list-style: none; display: flex; flex-direction: column; gap: 8px; margin-top: 12px; }
        .ed-action-card {
            background: var(--bg-surface);
            border-radius: var(--radius);
            overflow: hidden;
        }
        .ed-action-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
        }
        .ed-action-header .action-time { font-size: 13px; }
        .ed-action-header .action-name { flex: 1; font-size: 14px; }
        .ed-action-header .ed-btn-icon {
            background: none; border: none; color: var(--text-dim);
            font-size: 16px; min-height: 28px; min-width: 28px; padding: 2px;
            cursor: pointer;
        }
        .ed-action-header .ed-btn-icon:hover { color: var(--text); }

        .ed-action-edit {
            padding: 0 12px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-top: 1px solid rgba(255,255,255,0.06);
        }
        .ed-offset-row {
            display: flex; align-items: center; gap: 6px; margin-top: 4px;
        }
        .ed-offset-row input {
            width: 60px; background: var(--bg-input); color: var(--text);
            border: 1px solid rgba(255,255,255,0.12); border-radius: 6px;
            padding: 6px 8px; font-size: 14px; text-align: center;
            font-family: inherit;
        }
        .ed-offset-row input:focus { outline: none; border-color: var(--accent-blue); }
        .ed-offset-row span { color: var(--text-dim); font-size: 13px; }

        .ed-toggle-group {
            display: flex; gap: 6px; flex-wrap: wrap;
        }
        .ed-toggle-btn {
            min-height: 34px; padding: 6px 12px; font-size: 13px; font-weight: 500;
            background: var(--bg-input); color: var(--text-dim);
            border: 1px solid rgba(255,255,255,0.12); border-radius: 6px;
            cursor: pointer;
        }
        .ed-toggle-btn.selected {
            border-color: var(--accent-blue); color: var(--accent-blue);
            background: rgba(74,158,255,0.1);
        }

        .ed-form-actions {
            display: flex; gap: 8px; margin-top: 4px;
        }
        .ed-form-actions button { flex: 1; min-height: 36px; font-size: 13px; }

        .btn-add-action {
            width: 100%; min-height: 44px; font-size: 14px;
            background: transparent; color: var(--text-dim);
            border: 2px dashed rgba(255,255,255,0.15); border-radius: var(--radius);
            cursor: pointer; margin-top: 8px;
        }
        .btn-add-action:hover { border-color: var(--accent-blue); color: var(--accent-blue); }

        .share-section {
            display: flex; flex-direction: column; gap: 10px; margin-top: 16px;
        }
        .share-feedback {
            font-size: 13px; color: var(--accent-green);
            min-height: 20px; text-align: center;
            transition: opacity 0.3s;
        }

        .ed-checkbox-row {
            display: flex; align-items: center; gap: 8px;
        }
        .ed-checkbox-row input[type="checkbox"] {
            width: 18px; height: 18px; accent-color: var(--accent-blue);
        }
        .ed-checkbox-row label { font-size: 13px; color: var(--text-dim); }

        /* ─── Pack Manager screen ─── */
        .header-packs { background: #1a2e0d; }

        .pack-list { list-style: none; display: flex; flex-direction: column; gap: 8px; }
        .pack-card {
            background: var(--bg-surface);
            border-radius: var(--radius);
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .pack-info { flex: 1; min-width: 0; }
        .pack-name {
            font-size: 15px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .pack-meta { font-size: 12px; color: var(--text-dim); margin-top: 2px; }
        .pack-delete {
            min-height: 34px; min-width: 34px; padding: 4px 10px;
            font-size: 13px; font-weight: 500;
            background: transparent; color: var(--accent-red);
            border: 1px solid var(--accent-red); border-radius: 6px;
            cursor: pointer; flex-shrink: 0;
        }

        .pack-empty {
            text-align: center; padding: 32px 16px;
            color: var(--text-dim); font-size: 14px; line-height: 1.6;
        }

        .import-status {
            font-size: 13px; min-height: 20px; text-align: center;
            margin-top: 8px; transition: opacity 0.3s;
        }
        .import-status.error { color: var(--accent-red); }
        .import-status.success { color: var(--accent-green); }
        .import-status.progress { color: var(--accent-blue); }

        /* ─── Footer spacer for safe area ─── */
        .safe-bottom { height: env(safe-area-inset-bottom, 0px); flex-shrink: 0; }
    </style>
</head>
<body>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: INPUT                                                          -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-input" class="screen active">
    <div class="header header-input">
        <h1>Conductor</h1>
    </div>
    <div class="content">
        <div class="app-logo">
            <h2>CONDUCTOR</h2>
            <p>Create timed action sequences and share them as links.<br>Everyone's device counts down together.</p>
        </div>

        <details class="app-about">
            <summary>What is this?</summary>
            <div class="about-body">
                Conductor coordinates groups of people using their phones. An organizer creates a timed sequence of cues — spoken announcements, vibrations, or audio — and shares it as a link or QR code. Every participant's device plays the same cues at the same time. No accounts, no app store, no server required.
            </div>
        </details>

        <textarea id="input-paste" placeholder="Got an event code? Paste it here..."></textarea>
        <div id="input-error" class="error-msg"></div>
        <button id="btn-load" class="btn-primary">Load Event</button>

        <div class="separator">or</div>

        <button id="btn-demo" class="btn-outline">Load Demo Event</button>
        <span class="btn-hint">Try a sample event to see how it works</span>

        <div class="separator">or</div>

        <input type="file" id="event-file-input" accept=".json,.txt,.conductor" style="display:none;">
        <button id="btn-import-event" class="btn-outline">Import Event File</button>

        <div class="separator">or</div>

        <button id="btn-create" class="btn-green">Create New Event</button>

        <div style="flex:1"></div>
        <button id="btn-manage-packs" class="btn-outline" style="margin-top:16px;">Manage Packs</button>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: PACK MANAGER                                                   -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-packs" class="screen">
    <div class="header header-packs">
        <h1>Pack Manager</h1>
    </div>
    <div class="content">
        <div id="pack-list" class="pack-list"></div>
        <div id="pack-empty" class="pack-empty">
            No packs installed.<br>
            Import a .zip resource pack<br>for higher-quality audio.
        </div>

        <div style="flex:1"></div>

        <input type="file" id="pack-file-input" accept=".zip" style="display:none;">
        <button id="btn-import-pack" class="btn-primary" style="margin-top:16px;">Import Pack (.zip)</button>
        <div id="import-status" class="import-status"></div>

        <button id="btn-packs-back" class="btn-outline" style="margin-top:10px;">Back</button>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: PREVIEW                                                        -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-preview" class="screen">
    <div class="header header-preview">
        <h1>Event Preview</h1>
    </div>
    <div class="content">
        <div class="event-info">
            <h2 id="preview-title"></h2>
            <div id="preview-desc" class="desc"></div>
            <dl class="event-meta">
                <dt>Starts</dt>  <dd id="preview-start"></dd>
                <dt>Actions</dt> <dd id="preview-count"></dd>
                <dt>Duration</dt><dd id="preview-duration"></dd>
            </dl>
        </div>

        <ul id="preview-actions" class="action-list"></ul>

        <div style="flex:1"></div>

        <div style="display:flex; flex-direction:column; gap:10px; margin-top:16px;">
            <button id="btn-start-practice" class="btn-green">Start Practice</button>
            <button id="btn-preview-back" class="btn-outline">Back</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: PRACTICE                                                       -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-practice" class="screen">
    <div class="header header-practice">
        <h1 id="practice-title">Practice</h1>
        <span class="badge badge-practice">PRACTICE</span>
    </div>
    <div class="canvas-wrap">
        <canvas id="canvas-practice"></canvas>
    </div>
    <div class="controls">
        <div class="speed-row">
            <label>Speed</label>
            <input type="range" id="speed-slider" min="1" max="5" step="0.5" value="1">
            <span id="speed-val" class="speed-val">1x</span>
        </div>
        <div class="btn-row">
            <button id="btn-audio-toggle" class="icon-btn" title="Toggle audio">&#x1f50a;</button>
            <button id="btn-go-live" class="btn-red btn-small" style="flex:3">Go Live</button>
            <button id="btn-practice-stop" class="btn-outline btn-small">Stop</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: LIVE                                                           -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-live" class="screen">
    <div class="header header-live">
        <h1 id="live-title">Live</h1>
        <span class="badge badge-live">LIVE</span>
    </div>
    <div class="canvas-wrap">
        <canvas id="canvas-live"></canvas>
    </div>
    <div class="controls">
        <div class="btn-row">
            <button id="btn-audio-toggle-live" class="icon-btn" title="Toggle audio">&#x1f50a;</button>
            <button id="btn-live-stop" class="btn-outline btn-small" style="flex:3">Stop</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: COMPLETED                                                      -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-completed" class="screen">
    <div class="header header-done">
        <h1>Conductor</h1>
    </div>
    <div class="content">
        <div class="done-wrap">
            <div class="check">&#x2705;</div>
            <h2>Event Completed</h2>
            <p id="done-summary"></p>
        </div>
        <button id="btn-return" class="btn-primary" style="margin-top:auto;">Return to Start</button>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: EDITOR — Event Info (Step 1)                                    -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-editor-info" class="screen">
    <div class="header header-editor">
        <h1>New Event</h1>
        <span style="font-size:12px; color:var(--text-dim);">Step 1 of 3</span>
    </div>
    <div class="content">
        <label class="field-label">Event Title *</label>
        <input id="ed-title" class="field-input" type="text" placeholder="e.g. Flash Mob at Central Park" maxlength="80">

        <label class="field-label">Description</label>
        <textarea id="ed-description" class="field-textarea" placeholder="What is this event about?" maxlength="300"></textarea>

        <label class="field-label">Start Date & Time *</label>
        <input id="ed-datetime" class="field-input" type="datetime-local">

        <label class="field-label">Timezone</label>
        <select id="ed-timezone" class="field-select"></select>

        <div id="ed-info-error" class="error-msg" style="margin-top:10px;"></div>

        <div style="flex:1"></div>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:16px;">
            <button id="btn-ed-next1" class="btn-primary">Next: Timeline</button>
            <button id="btn-ed-cancel" class="btn-outline">Cancel</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: EDITOR — Timeline Builder (Step 2)                              -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-editor-timeline" class="screen">
    <div class="header header-editor">
        <h1>Timeline</h1>
        <span style="font-size:12px; color:var(--text-dim);">Step 2 of 3</span>
    </div>
    <div class="content">
        <p style="font-size:13px; color:var(--text-dim); margin-bottom:8px;">
            Add actions with timing relative to the event start.
        </p>

        <div id="ed-action-list" class="ed-action-list"></div>
        <button id="btn-add-action" class="btn-add-action">+ Add Action</button>

        <div id="ed-timeline-error" class="error-msg" style="margin-top:10px;"></div>

        <div style="flex:1"></div>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:16px;">
            <button id="btn-ed-next2" class="btn-primary">Next: Review & Share</button>
            <button id="btn-ed-back1" class="btn-outline">Back</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: EDITOR — Review & Share (Step 3)                                -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-editor-review" class="screen">
    <div class="header header-editor">
        <h1>Review & Share</h1>
        <span style="font-size:12px; color:var(--text-dim);">Step 3 of 3</span>
    </div>
    <div class="content">
        <div class="event-info">
            <h2 id="review-title"></h2>
            <div id="review-desc" class="desc"></div>
            <dl class="event-meta">
                <dt>Starts</dt>  <dd id="review-start"></dd>
                <dt>Actions</dt> <dd id="review-count"></dd>
                <dt>Duration</dt><dd id="review-duration"></dd>
            </dl>
        </div>

        <ul id="review-actions" class="action-list"></ul>

        <div class="share-section">
            <div id="share-feedback" class="share-feedback"></div>
            <div id="qr-container" style="display:none; text-align:center; margin:8px 0;">
                <canvas id="qr-canvas" style="border-radius:8px;"></canvas>
                <div id="qr-warning" style="font-size:12px; color:var(--accent-gold); margin-top:4px;"></div>
            </div>
            <button id="btn-show-qr" class="btn-outline">Show QR Code</button>
            <button id="btn-copy-code" class="btn-primary">Copy Event Code</button>
            <button id="btn-copy-link" class="btn-primary">Copy Shareable Link</button>
            <button id="btn-web-share" class="btn-primary" style="display:none;">Share via...</button>
            <button id="btn-download-html" class="btn-outline">Download Bundled HTML</button>
        </div>

        <div style="flex:1"></div>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:16px;">
            <button id="btn-preview-from-editor" class="btn-green">Preview Event</button>
            <button id="btn-ed-back2" class="btn-outline">Back</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- Scripts                                                                 -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<script src="lib/pako.min.js"></script>
<script src="lib/qr-creator.min.js"></script>
<script src="js/models.js"></script>
<script src="js/eventEncoder.js"></script>
<script src="js/timingEngine.js"></script>
<script src="js/audioService.js"></script>
<script src="js/resourcePackManager.js"></script>
<script src="js/circularTimeline.js"></script>

<script>
// ═══════════════════════════════════════════════════════════════════════════
// Global Error Handlers
// ═══════════════════════════════════════════════════════════════════════════

window.addEventListener('error', (e) => {
    console.error('Conductor error:', e.error);
});
window.addEventListener('unhandledrejection', (e) => {
    console.error('Conductor unhandled promise:', e.reason);
});

// ═══════════════════════════════════════════════════════════════════════════
// App State
// ═══════════════════════════════════════════════════════════════════════════

const state = {
    mode: 'input',              // 'input' | 'preview' | 'practice' | 'live' | 'completed' | 'editor-info' | 'editor-timeline' | 'editor-review' | 'packs'
    event: null,                // Full Event object
    speedMultiplier: 1,         // 1-5x (practice only)
    audioMuted: false,
    practiceStartRealMs: 0,     // Wall clock when practice started
    practiceStartEventMs: 0,    // Event time practice started from
    wakeLock: null,             // Wake Lock sentinel
    previewReturnTo: 'input',   // Where preview "Back" returns to
    editor: {
        title: '',
        description: '',
        startDateTime: '',      // "YYYY-MM-DDTHH:MM" for datetime-local input
        timezone: '',           // IANA timezone string
        actions: [],            // Array of { offsetSeconds, action, style, hapticPattern, countdown, audioAnnounce }
        editingIndex: -1,       // Which action card has edit form open (-1 = none)
    },
};

// ═══════════════════════════════════════════════════════════════════════════
// Services (created once)
// ═══════════════════════════════════════════════════════════════════════════

const audio = createAudioService();
const packManager = createResourcePackManager();
let timelinePractice = null;    // CircularTimeline for practice canvas
let timelineLive = null;        // CircularTimeline for live canvas

// Wire resource pack resolver into audio service
audio.setResourcePackResolver(packManager.getResolver());

// Dev hook for console testing: window.importPack(arrayBuffer)
window.importPack = async (arrayBuffer) => {
    const manifest = await packManager.importPack(arrayBuffer, console.log);
    await packManager.ensurePackLoaded(manifest.id);
    console.log('Pack imported and loaded:', manifest.name, '— cues:', Object.keys(manifest.cues));
    return manifest;
};

// Loop handles
let rafId = null;
let audioIntervalId = null;

// ═══════════════════════════════════════════════════════════════════════════
// DOM references
// ═══════════════════════════════════════════════════════════════════════════

const $ = (id) => document.getElementById(id);
const screens = {
    'input':           $('screen-input'),
    'preview':         $('screen-preview'),
    'practice':        $('screen-practice'),
    'live':            $('screen-live'),
    'completed':       $('screen-completed'),
    'editor-info':     $('screen-editor-info'),
    'editor-timeline': $('screen-editor-timeline'),
    'editor-review':   $('screen-editor-review'),
    'packs':           $('screen-packs'),
};

// ═══════════════════════════════════════════════════════════════════════════
// Screen transitions
// ═══════════════════════════════════════════════════════════════════════════

function transitionTo(newMode) {
    // 1. Stop any running loops
    stopLoops();

    // 2. Release wake lock if leaving practice/live
    if (state.mode === 'practice' || state.mode === 'live') {
        releaseWakeLock();
    }

    // 3. Hide all screens
    for (const s of Object.values(screens)) {
        s.classList.remove('active');
    }

    // 4. Show target
    screens[newMode].classList.add('active');
    state.mode = newMode;

    // 5. Focus management — announce new screen to assistive tech
    const heading = screens[newMode].querySelector('h1');
    if (heading) {
        heading.setAttribute('tabindex', '-1');
        heading.focus();
    }

    // 6. Initialize mode-specific state
    switch (newMode) {
        case 'input':
            $('input-paste').value = '';
            $('input-error').textContent = '';
            break;

        case 'preview':
            renderPreview();
            break;

        case 'practice':
            enterPractice();
            break;

        case 'live':
            enterLive();
            break;

        case 'completed':
            renderCompleted();
            break;

        case 'editor-info':
            initEditorInfo();
            break;

        case 'editor-timeline':
            renderEditorTimeline();
            break;

        case 'editor-review':
            finalizeEditorEvent();
            renderEditorReview();
            break;

        case 'packs':
            renderPackManager();
            break;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// INPUT screen logic
// ═══════════════════════════════════════════════════════════════════════════

function loadFromString(input) {
    const trimmed = input.trim();
    if (!trimmed) {
        $('input-error').textContent = 'Please paste an event code, JSON, or text-format event.';
        return false;
    }
    try {
        const embedded = parseEventInput(trimmed);
        state.event = embeddedEventToEvent(embedded);
        return true;
    } catch (e) {
        $('input-error').textContent = e.message;
        return false;
    }
}

function loadFromHash() {
    const hash = location.hash.substring(1); // strip '#'
    if (!hash) return false;
    try {
        const embedded = parseEventInput(hash);
        state.event = embeddedEventToEvent(embedded);
        return true;
    } catch (e) {
        return false;
    }
}

function createDemoEvent() {
    const now = Date.now();
    const startMs = now + 10 * 1000; // 10 seconds from now
    const startTime = new Date(startMs).toISOString();

    const actions = [
        { offset: 0,   action: 'Get ready',        style: 'normal',   hapticPattern: 'single' },
        { offset: 15,  action: 'Wave left',         style: 'normal',   hapticPattern: 'double' },
        { offset: 30,  action: 'Wave right',        style: 'emphasis', hapticPattern: 'double' },
        { offset: 60,  action: 'Jump!',             style: 'alert',    hapticPattern: 'triple',
          countdownSeconds: [5, 4, 3, 2, 1] },
        { offset: 90,  action: 'Freeze in place',   style: 'emphasis', hapticPattern: 'double' },
    ];

    const timeline = actions.map(a => createTimelineAction({
        time: new Date(startMs + a.offset * 1000).toISOString(),
        action: a.action,
        style: a.style,
        hapticPattern: a.hapticPattern,
        countdownSeconds: a.countdownSeconds || null,
        noticeSeconds: 5,
    }));

    const embedded = {
        title: 'Demo Flash Mob',
        description: 'A quick demo event to test Conductor. Actions start in ~10 seconds.',
        startTime: startTime,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timeline: timeline,
    };

    state.event = embeddedEventToEvent(embedded);
}

// ═══════════════════════════════════════════════════════════════════════════
// PREVIEW screen logic
// ═══════════════════════════════════════════════════════════════════════════

function renderPreview() {
    const evt = state.event;
    if (!evt) return;

    $('preview-title').textContent = evt.title;
    $('preview-desc').textContent = evt.description || '';
    $('preview-start').textContent = utcToLocalDisplay(evt.startTime, evt.timezone);
    $('preview-count').textContent = evt.timeline.length + ' actions';

    // Duration
    if (evt.timeline.length > 0) {
        const sorted = [...evt.timeline].sort((a, b) =>
            (a.timeMs ?? new Date(a.time).getTime()) - (b.timeMs ?? new Date(b.time).getTime())
        );
        const firstMs = sorted[0].timeMs ?? new Date(sorted[0].time).getTime();
        const lastMs = sorted[sorted.length - 1].timeMs ?? new Date(sorted[sorted.length - 1].time).getTime();
        const durationSec = Math.round((lastMs - firstMs) / 1000);
        const mins = Math.floor(durationSec / 60);
        const secs = durationSec % 60;
        $('preview-duration').textContent = mins > 0
            ? `${mins}m ${secs}s`
            : `${secs}s`;
    } else {
        $('preview-duration').textContent = '0s';
    }

    // Action list
    const list = $('preview-actions');
    list.innerHTML = '';
    const startMs = new Date(evt.startTime).getTime();

    for (const action of evt.timeline) {
        const actionMs = action.timeMs ?? new Date(action.time).getTime();
        const offsetSec = Math.round((actionMs - startMs) / 1000);
        const mins = Math.floor(offsetSec / 60);
        const secs = offsetSec % 60;

        const li = document.createElement('li');
        li.innerHTML = `
            <span class="action-dot ${action.style || 'normal'}"></span>
            <span class="action-time">${mins > 0 ? mins + ':' + String(secs).padStart(2,'0') : secs + 's'}</span>
            <span>${escapeHtml(action.action)}</span>
        `;
        list.appendChild(li);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// PRACTICE mode
// ═══════════════════════════════════════════════════════════════════════════

function enterPractice() {
    const evt = state.event;
    if (!evt || evt.timeline.length === 0) return;

    $('practice-title').textContent = evt.title;

    // Initialize audio on first user gesture
    if (!audio.isInitialized()) {
        audio.initialize();
    }
    audio.reset();
    audio.setMuted(state.audioMuted);

    // Pre-load resource packs referenced by event actions
    preloadEventPacks(evt);

    // Set practice start: begin 15s before first action
    const sorted = [...evt.timeline].sort((a, b) =>
        (a.timeMs ?? new Date(a.time).getTime()) - (b.timeMs ?? new Date(b.time).getTime())
    );
    const firstActionMs = sorted[0].timeMs ?? new Date(sorted[0].time).getTime();
    state.practiceStartRealMs = Date.now();
    state.practiceStartEventMs = firstActionMs - 15000;
    state.speedMultiplier = parseFloat($('speed-slider').value);

    // Create timeline renderer
    const canvas = $('canvas-practice');
    timelinePractice = createCircularTimeline(canvas);
    timelinePractice.setEvent(evt);
    timelinePractice.resize();

    // Start loops
    startPracticeLoop();
    startAudioLoop('practice');
    requestWakeLock();
}

function startPracticeLoop() {
    function frame() {
        if (state.mode !== 'practice') return;
        const virtualNow = getPracticeNow(
            Date.now(),
            state.practiceStartRealMs,
            state.practiceStartEventMs,
            state.speedMultiplier
        );
        timelinePractice.setNowMs(virtualNow);
        timelinePractice.render();
        rafId = requestAnimationFrame(frame);
    }
    rafId = requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════════════════════════
// LIVE mode
// ═══════════════════════════════════════════════════════════════════════════

function enterLive() {
    const evt = state.event;
    if (!evt || evt.timeline.length === 0) return;

    // If all actions are >5 minutes past, go straight to completed
    const now = Date.now();
    const allPast = evt.timeline.every(a => (now - (a.timeMs ?? new Date(a.time).getTime())) > 5 * 60 * 1000);
    if (allPast) {
        transitionTo('completed');
        return;
    }

    $('live-title').textContent = evt.title;

    // Initialize audio on first user gesture
    if (!audio.isInitialized()) {
        audio.initialize();
    }
    audio.reset();
    audio.setMuted(state.audioMuted);

    // Pre-load resource packs referenced by event actions
    preloadEventPacks(evt);

    // Create timeline renderer
    const canvas = $('canvas-live');
    timelineLive = createCircularTimeline(canvas);
    timelineLive.setEvent(evt);
    timelineLive.resize();

    // Start loops
    startLiveLoop();
    startAudioLoop('live');
    requestWakeLock();
}

function startLiveLoop() {
    function frame() {
        if (state.mode !== 'live') return;
        const now = Date.now();
        timelineLive.setNowMs(now);
        timelineLive.render();

        // Auto-complete: check if all actions are past
        checkCompletion(now);

        rafId = requestAnimationFrame(frame);
    }
    rafId = requestAnimationFrame(frame);
}

function checkCompletion(nowMs) {
    const evt = state.event;
    if (!evt) return;
    const endMs = new Date(evt.endTime).getTime();
    if (nowMs > endMs) {
        transitionTo('completed');
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Audio loop (shared by practice + live)
// ═══════════════════════════════════════════════════════════════════════════

function startAudioLoop(mode) {
    audioIntervalId = setInterval(() => {
        if (state.mode !== mode) return;

        const evt = state.event;
        if (!evt) return;

        const nowMs = (mode === 'practice')
            ? getPracticeNow(Date.now(), state.practiceStartRealMs,
                             state.practiceStartEventMs, state.speedMultiplier)
            : Date.now();

        const speedMult = (mode === 'practice') ? state.speedMultiplier : 1;

        for (const action of evt.timeline) {
            const secUntil = calculateTimeUntilPrecise(action, nowMs);

            // Only process actions within announcement range
            if (secUntil < -2 || secUntil > evt.defaultNoticeSeconds + 2) continue;

            const result = audio.announceAction(
                action, secUntil, evt.defaultNoticeSeconds, speedMult
            );

            // Haptic on trigger
            if (result && result.startsWith('trigger')) {
                audio.haptic(action.hapticPattern || 'double');
            }
        }
    }, 100); // 10Hz
}

// ═══════════════════════════════════════════════════════════════════════════
// COMPLETED screen
// ═══════════════════════════════════════════════════════════════════════════

function renderCompleted() {
    const evt = state.event;
    if (!evt) return;
    $('done-summary').textContent = `"${evt.title}" — ${evt.timeline.length} actions completed.`;
}

// ═══════════════════════════════════════════════════════════════════════════
// Loop management
// ═══════════════════════════════════════════════════════════════════════════

function stopLoops() {
    if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
    }
    if (audioIntervalId) {
        clearInterval(audioIntervalId);
        audioIntervalId = null;
    }
    // Stop any speech in progress
    if (window.speechSynthesis) {
        speechSynthesis.cancel();
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Wake Lock
// ═══════════════════════════════════════════════════════════════════════════

async function requestWakeLock() {
    try {
        if ('wakeLock' in navigator) {
            state.wakeLock = await navigator.wakeLock.request('screen');
        }
    } catch (e) {
        // Wake lock can fail (e.g. low battery, not visible)
    }
}

function releaseWakeLock() {
    if (state.wakeLock) {
        state.wakeLock.release().catch(() => {});
        state.wakeLock = null;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page Visibility (re-acquire wake lock, pause/resume audio)
// ═══════════════════════════════════════════════════════════════════════════

document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        // Re-request wake lock (released on page hide)
        if (state.mode === 'practice' || state.mode === 'live') {
            requestWakeLock();
        }
    }
});

// ═══════════════════════════════════════════════════════════════════════════
// Resize handling
// ═══════════════════════════════════════════════════════════════════════════

window.addEventListener('resize', () => {
    if (state.mode === 'practice' && timelinePractice) {
        timelinePractice.resize();
    }
    if (state.mode === 'live' && timelineLive) {
        timelineLive.resize();
    }
});

// ═══════════════════════════════════════════════════════════════════════════
// Audio mute toggle
// ═══════════════════════════════════════════════════════════════════════════

function updateMuteButtons() {
    const icon = state.audioMuted ? '\u{1F507}' : '\u{1F50A}';
    const cls = state.audioMuted ? 'icon-btn muted' : 'icon-btn';
    $('btn-audio-toggle').textContent = icon;
    $('btn-audio-toggle').className = cls;
    $('btn-audio-toggle-live').textContent = icon;
    $('btn-audio-toggle-live').className = cls;
}

function toggleMute() {
    state.audioMuted = !state.audioMuted;
    audio.setMuted(state.audioMuted);
    updateMuteButtons();
}

// ═══════════════════════════════════════════════════════════════════════════
// Utility
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Pre-load resource packs referenced by event actions.
 * Fires async — doesn't block mode entry; audio falls back to TTS if not ready.
 */
function preloadEventPacks(evt) {
    const packIds = new Set();
    for (const action of evt.timeline) {
        if (action.pack) packIds.add(action.pack);
    }
    for (const packId of packIds) {
        packManager.ensurePackLoaded(packId).catch(() => {});
    }
}

function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

async function copyToClipboard(text) {
    try {
        await navigator.clipboard.writeText(text);
        return true;
    } catch {
        // Fallback for HTTP / older browsers / file:// context
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.cssText = 'position:fixed;left:-9999px';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// EDITOR — Event Info (Step 1)
// ═══════════════════════════════════════════════════════════════════════════

const COMMON_TIMEZONES = [
    'Pacific/Honolulu', 'America/Anchorage', 'America/Los_Angeles',
    'America/Denver', 'America/Chicago', 'America/New_York',
    'America/Sao_Paulo', 'Atlantic/Reykjavik', 'Europe/London',
    'Europe/Paris', 'Europe/Berlin', 'Europe/Helsinki',
    'Africa/Cairo', 'Asia/Dubai', 'Asia/Kolkata',
    'Asia/Bangkok', 'Asia/Shanghai', 'Asia/Tokyo',
    'Australia/Sydney', 'Pacific/Auckland',
];

function resetEditorState() {
    state.editor = {
        title: '',
        description: '',
        startDateTime: '',
        timezone: '',
        actions: [],
        editingIndex: -1,
    };
}

function getDefaultDateTime() {
    const now = new Date();
    now.setMinutes(Math.ceil(now.getMinutes() / 5) * 5, 0, 0);
    now.setHours(now.getHours() + 1);
    // Format as YYYY-MM-DDTHH:MM in local time
    const y = now.getFullYear();
    const mo = String(now.getMonth() + 1).padStart(2, '0');
    const d = String(now.getDate()).padStart(2, '0');
    const h = String(now.getHours()).padStart(2, '0');
    const mi = String(now.getMinutes()).padStart(2, '0');
    return `${y}-${mo}-${d}T${h}:${mi}`;
}

function populateTimezoneSelect(selected) {
    const sel = $('ed-timezone');
    sel.innerHTML = '';
    for (const tz of COMMON_TIMEZONES) {
        const opt = document.createElement('option');
        opt.value = tz;
        opt.textContent = tz.replace(/_/g, ' ');
        if (tz === selected) opt.selected = true;
        sel.appendChild(opt);
    }
    // If user's timezone isn't in the list, add it
    if (selected && !COMMON_TIMEZONES.includes(selected)) {
        const opt = document.createElement('option');
        opt.value = selected;
        opt.textContent = selected.replace(/_/g, ' ');
        opt.selected = true;
        sel.insertBefore(opt, sel.firstChild);
    }
}

function initEditorInfo() {
    const ed = state.editor;
    $('ed-title').value = ed.title;
    $('ed-description').value = ed.description;
    $('ed-datetime').value = ed.startDateTime || getDefaultDateTime();
    const tz = ed.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
    populateTimezoneSelect(tz);
    $('ed-info-error').textContent = '';
}

function saveEditorInfo() {
    const title = $('ed-title').value.trim();
    const datetime = $('ed-datetime').value;
    // Reset error state (fixes gold color getting stuck from past-time warning)
    $('ed-info-error').textContent = '';
    $('ed-info-error').style.color = '';
    if (!title) {
        $('ed-info-error').textContent = 'Title is required.';
        return false;
    }
    if (!datetime) {
        $('ed-info-error').textContent = 'Start date/time is required.';
        return false;
    }
    // Warn (not block) if start time is in the past
    try {
        const tz = $('ed-timezone').value;
        const utcStr = localDateTimeToUTC(datetime, tz);
        if (new Date(utcStr).getTime() < Date.now()) {
            $('ed-info-error').textContent = 'Note: start time is in the past.';
            $('ed-info-error').style.color = 'var(--accent-gold)';
        }
    } catch { /* timezone conversion can fail on exotic timezones, proceed anyway */ }

    state.editor.title = title;
    state.editor.description = $('ed-description').value.trim();
    state.editor.startDateTime = datetime;
    state.editor.timezone = $('ed-timezone').value;
    return true;
}

// ═══════════════════════════════════════════════════════════════════════════
// EDITOR — Timeline Builder (Step 2)
// ═══════════════════════════════════════════════════════════════════════════

function renderEditorTimeline() {
    const list = $('ed-action-list');
    list.innerHTML = '';
    $('ed-timeline-error').textContent = '';

    // Sort actions by offset
    state.editor.actions.sort((a, b) => a.offsetSeconds - b.offsetSeconds);

    state.editor.actions.forEach((action, index) => {
        const card = createActionCard(action, index);
        list.appendChild(card);
    });
}

function formatOffset(totalSec) {
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return m > 0 ? `${m}:${String(s).padStart(2, '0')}` : `${s}s`;
}

function createActionCard(action, index) {
    const card = document.createElement('div');
    card.className = 'ed-action-card';
    card.dataset.index = index;

    const header = document.createElement('div');
    header.className = 'ed-action-header';
    header.innerHTML = `
        <span class="action-dot ${action.style || 'normal'}"></span>
        <span class="action-time">${formatOffset(action.offsetSeconds)}</span>
        <span class="action-name">${escapeHtml(action.action)}</span>
        <button class="ed-btn-icon ed-btn-edit" title="Edit">&#9998;</button>
        <button class="ed-btn-icon ed-btn-delete" title="Delete">&#10005;</button>
    `;
    card.appendChild(header);

    // Show edit form if this card is being edited
    if (state.editor.editingIndex === index) {
        card.appendChild(createActionEditForm(action, index));
    }

    return card;
}

function createActionEditForm(action, index) {
    const form = document.createElement('div');
    form.className = 'ed-action-edit';

    const mins = Math.floor(action.offsetSeconds / 60);
    const secs = action.offsetSeconds % 60;

    form.innerHTML = `
        <label class="field-label" style="margin-top:8px;">Offset from start</label>
        <div class="ed-offset-row">
            <input type="number" class="ed-offset-min" value="${mins}" min="0" max="999" placeholder="0">
            <span>min</span>
            <input type="number" class="ed-offset-sec" value="${secs}" min="0" max="59" placeholder="0">
            <span>sec</span>
        </div>

        <label class="field-label">Action text *</label>
        <input type="text" class="field-input ed-action-text" value="${escapeHtml(action.action)}" placeholder="e.g. Wave left" maxlength="80">

        <label class="field-label">Style</label>
        <div class="ed-toggle-group ed-style-group">
            <button type="button" class="ed-toggle-btn${action.style === 'normal' ? ' selected' : ''}" data-val="normal">Normal</button>
            <button type="button" class="ed-toggle-btn${action.style === 'emphasis' ? ' selected' : ''}" data-val="emphasis">Emphasis</button>
            <button type="button" class="ed-toggle-btn${action.style === 'alert' ? ' selected' : ''}" data-val="alert">Alert</button>
        </div>

        <label class="field-label">Haptic</label>
        <div class="ed-toggle-group ed-haptic-group">
            <button type="button" class="ed-toggle-btn${action.hapticPattern === 'single' ? ' selected' : ''}" data-val="single">Single</button>
            <button type="button" class="ed-toggle-btn${action.hapticPattern === 'double' ? ' selected' : ''}" data-val="double">Double</button>
            <button type="button" class="ed-toggle-btn${action.hapticPattern === 'triple' ? ' selected' : ''}" data-val="triple">Triple</button>
        </div>

        <div class="ed-checkbox-row">
            <input type="checkbox" id="ed-countdown-${index}" class="ed-countdown-check" ${action.countdown ? 'checked' : ''}>
            <label for="ed-countdown-${index}">5-second countdown</label>
        </div>

        <label class="field-label">Resource Pack</label>
        <select class="field-select ed-pack-select">
            <option value="">None (TTS only)</option>
        </select>
        <select class="field-select ed-cue-select" style="display:none; margin-top:6px;">
            <option value="">Select a cue...</option>
        </select>
        <input type="text" class="field-input ed-fallback-text" placeholder="TTS fallback text" style="display:none; margin-top:6px;" value="${escapeHtml(action.fallbackText || action.action)}" maxlength="80">

        <div class="ed-form-actions">
            <button type="button" class="btn-primary btn-small ed-btn-save">Save</button>
            <button type="button" class="btn-outline btn-small ed-btn-form-cancel">Cancel</button>
        </div>
    `;

    // Populate pack dropdown async
    populatePackDropdown(form, action);

    return form;
}

async function populatePackDropdown(form, action) {
    const packSelect = form.querySelector('.ed-pack-select');
    const cueSelect = form.querySelector('.ed-cue-select');
    const fallbackInput = form.querySelector('.ed-fallback-text');

    try {
        const packs = await packManager.listPacks();
        for (const pack of packs) {
            const opt = document.createElement('option');
            opt.value = pack.id;
            opt.textContent = pack.name;
            if (action.pack === pack.id) opt.selected = true;
            packSelect.appendChild(opt);
        }

        // If action already has a pack, show cue dropdown
        if (action.pack) {
            await populateCueDropdown(cueSelect, action.pack, action.cue);
            cueSelect.style.display = '';
            fallbackInput.style.display = '';
        }
    } catch { /* IDB not available — leave default */ }

    // Wire pack change → populate cues
    packSelect.addEventListener('change', async () => {
        const packId = packSelect.value;
        if (!packId) {
            cueSelect.style.display = 'none';
            fallbackInput.style.display = 'none';
            cueSelect.innerHTML = '<option value="">Select a cue...</option>';
            return;
        }
        await populateCueDropdown(cueSelect, packId, null);
        cueSelect.style.display = '';
        fallbackInput.style.display = '';
    });
}

async function populateCueDropdown(cueSelect, packId, selectedCue) {
    cueSelect.innerHTML = '<option value="">Select a cue...</option>';
    const cues = await packManager.getCueList(packId);
    for (const cueId of cues) {
        const opt = document.createElement('option');
        opt.value = cueId;
        opt.textContent = cueId;
        if (cueId === selectedCue) opt.selected = true;
        cueSelect.appendChild(opt);
    }
}

// Event delegation for timeline editor actions
$('ed-action-list').addEventListener('click', (e) => {
    const card = e.target.closest('.ed-action-card');
    if (!card) return;
    const index = parseInt(card.dataset.index);

    // Toggle buttons (style / haptic)
    if (e.target.classList.contains('ed-toggle-btn')) {
        const group = e.target.closest('.ed-toggle-group');
        group.querySelectorAll('.ed-toggle-btn').forEach(b => b.classList.remove('selected'));
        e.target.classList.add('selected');
        return;
    }

    // Edit button
    if (e.target.closest('.ed-btn-edit')) {
        state.editor.editingIndex = (state.editor.editingIndex === index) ? -1 : index;
        renderEditorTimeline();
        return;
    }

    // Delete button
    if (e.target.closest('.ed-btn-delete')) {
        state.editor.actions.splice(index, 1);
        if (state.editor.editingIndex === index) state.editor.editingIndex = -1;
        else if (state.editor.editingIndex > index) state.editor.editingIndex--;
        renderEditorTimeline();
        return;
    }

    // Save action form
    if (e.target.closest('.ed-btn-save')) {
        const editForm = card.querySelector('.ed-action-edit');
        const actionText = editForm.querySelector('.ed-action-text').value.trim();
        if (!actionText) return; // silently refuse

        const minVal = parseInt(editForm.querySelector('.ed-offset-min').value) || 0;
        const secVal = parseInt(editForm.querySelector('.ed-offset-sec').value) || 0;
        const offset = Math.max(0, minVal * 60 + secVal);

        const styleBtn = editForm.querySelector('.ed-style-group .ed-toggle-btn.selected');
        const hapticBtn = editForm.querySelector('.ed-haptic-group .ed-toggle-btn.selected');
        const countdownCheck = editForm.querySelector('.ed-countdown-check');

        const packSelect = editForm.querySelector('.ed-pack-select');
        const cueSelect = editForm.querySelector('.ed-cue-select');
        const fallbackInput = editForm.querySelector('.ed-fallback-text');

        const packId = packSelect ? packSelect.value : '';
        const cueId = cueSelect ? cueSelect.value : '';
        const fallbackText = fallbackInput ? fallbackInput.value.trim() : '';

        state.editor.actions[index] = {
            offsetSeconds: offset,
            action: actionText,
            style: styleBtn ? styleBtn.dataset.val : 'normal',
            hapticPattern: hapticBtn ? hapticBtn.dataset.val : 'double',
            countdown: countdownCheck.checked,
            audioAnnounce: true,
            pack: packId || null,
            cue: cueId || null,
            fallbackText: (packId && cueId && fallbackText) ? fallbackText : null,
        };
        state.editor.editingIndex = -1;
        renderEditorTimeline();
        return;
    }

    // Cancel edit form
    if (e.target.closest('.ed-btn-form-cancel')) {
        // If this was a new empty action, remove it
        if (!state.editor.actions[index].action) {
            state.editor.actions.splice(index, 1);
        }
        state.editor.editingIndex = -1;
        renderEditorTimeline();
        return;
    }
});

function addNewAction() {
    const lastOffset = state.editor.actions.length > 0
        ? state.editor.actions[state.editor.actions.length - 1].offsetSeconds + 15
        : 0;
    state.editor.actions.push({
        offsetSeconds: lastOffset,
        action: '',
        style: 'normal',
        hapticPattern: 'double',
        countdown: false,
        audioAnnounce: true,
    });
    // Sort so the new action lands in the right spot
    state.editor.actions.sort((a, b) => a.offsetSeconds - b.offsetSeconds);
    // Find the index of the newly added action (the one with empty text)
    const newIndex = state.editor.actions.findIndex(a => a.action === '');
    state.editor.editingIndex = newIndex >= 0 ? newIndex : state.editor.actions.length - 1;
    renderEditorTimeline();
}

// ═══════════════════════════════════════════════════════════════════════════
// EDITOR — Review & Share (Step 3)
// ═══════════════════════════════════════════════════════════════════════════

function localDateTimeToUTC(localStr, timezone) {
    // localStr is "YYYY-MM-DDTHH:MM"
    // We need to interpret this as a time in the given timezone and convert to UTC
    const [datePart, timePart] = localStr.split('T');
    const [year, month, day] = datePart.split('-').map(Number);
    const [hour, minute] = timePart.split(':').map(Number);

    // Initial guess: create a Date from UTC and adjust
    let guess = new Date(Date.UTC(year, month - 1, day, hour, minute, 0));

    // Use Intl to find what the local time would be at our guess
    for (let i = 0; i < 3; i++) {
        const fmt = new Intl.DateTimeFormat('en-US', {
            timeZone: timezone,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', hour12: false,
        });
        const parts = {};
        for (const p of fmt.formatToParts(guess)) {
            parts[p.type] = parseInt(p.value);
        }
        // hour can be 24 in some locales meaning midnight
        if (parts.hour === 24) parts.hour = 0;

        const diffMin = (hour - parts.hour) * 60 + (minute - parts.minute);
        const diffDay = day - parts.day;

        if (diffMin === 0 && diffDay === 0) break;
        guess = new Date(guess.getTime() + (diffMin + diffDay * 24 * 60) * 60000);
    }

    return guess.toISOString();
}

function finalizeEditorEvent() {
    const ed = state.editor;
    const startUTC = localDateTimeToUTC(ed.startDateTime, ed.timezone);
    const startMs = new Date(startUTC).getTime();

    const timeline = ed.actions.map(a => createTimelineAction({
        time: new Date(startMs + a.offsetSeconds * 1000).toISOString(),
        action: a.action,
        style: a.style,
        hapticPattern: a.hapticPattern,
        countdownSeconds: a.countdown ? [5, 4, 3, 2, 1] : null,
        audioAnnounce: a.audioAnnounce,
        noticeSeconds: 5,
        pack: a.pack || null,
        cue: a.cue || null,
        fallbackText: a.fallbackText || null,
    }));

    const embedded = {
        title: ed.title,
        description: ed.description || null,
        startTime: startUTC,
        timezone: ed.timezone,
        timeline: timeline,
    };

    state.event = embeddedEventToEvent(embedded);
}

function renderEditorReview() {
    const evt = state.event;
    if (!evt) return;

    $('review-title').textContent = evt.title;
    $('review-desc').textContent = evt.description || '';
    $('review-start').textContent = utcToLocalDisplay(evt.startTime, evt.timezone);
    $('review-count').textContent = evt.timeline.length + ' actions';

    // Duration
    if (evt.timeline.length > 0) {
        const sorted = [...evt.timeline].sort((a, b) =>
            (a.timeMs ?? new Date(a.time).getTime()) - (b.timeMs ?? new Date(b.time).getTime())
        );
        const firstMs = sorted[0].timeMs ?? new Date(sorted[0].time).getTime();
        const lastMs = sorted[sorted.length - 1].timeMs ?? new Date(sorted[sorted.length - 1].time).getTime();
        const durationSec = Math.round((lastMs - firstMs) / 1000);
        const mins = Math.floor(durationSec / 60);
        const secs = durationSec % 60;
        $('review-duration').textContent = mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
    } else {
        $('review-duration').textContent = '0s';
    }

    // Action list
    const list = $('review-actions');
    list.innerHTML = '';
    const startMs = new Date(evt.startTime).getTime();

    for (const action of evt.timeline) {
        const actionMs = action.timeMs ?? new Date(action.time).getTime();
        const offsetSec = Math.round((actionMs - startMs) / 1000);
        const mins = Math.floor(offsetSec / 60);
        const secs = offsetSec % 60;

        const li = document.createElement('li');
        li.innerHTML = `
            <span class="action-dot ${action.style || 'normal'}"></span>
            <span class="action-time">${mins > 0 ? mins + ':' + String(secs).padStart(2, '0') : secs + 's'}</span>
            <span>${escapeHtml(action.action)}</span>
        `;
        list.appendChild(li);
    }

    // Show/hide Web Share button
    if (navigator.share) {
        $('btn-web-share').style.display = '';
    }

    // URL length warning
    try {
        const encoded = encodeEvent(evt);
        const fullUrl = location.origin + location.pathname + '#' + encoded;
        if (fullUrl.length > 2000) {
            $('share-feedback').textContent = 'Long URL — "Copy Event Code" recommended over link sharing.';
            $('share-feedback').style.color = 'var(--accent-gold)';
            $('share-feedback').style.opacity = '1';
            return;
        }
    } catch { /* encoding can fail on edge cases */ }

    $('share-feedback').textContent = '';
}

// ═══════════════════════════════════════════════════════════════════════════
// Sharing Functions
// ═══════════════════════════════════════════════════════════════════════════

function showShareFeedback(msg) {
    const el = $('share-feedback');
    el.style.color = '';
    el.textContent = msg;
    el.style.opacity = '1';
    setTimeout(() => { el.style.opacity = '0'; }, 2500);
}

function sanitizeFilename(name) {
    return name.replace(/[^a-zA-Z0-9_\- ]/g, '').trim().replace(/\s+/g, '-').substring(0, 50) || 'conductor-event';
}

async function copyEventCode() {
    const encoded = encodeEvent(state.event);
    const ok = await copyToClipboard(encoded);
    showShareFeedback(ok ? 'Event code copied!' : 'Copy failed — try again.');
}

async function copyShareableLink() {
    const encoded = encodeEvent(state.event);
    const url = location.origin + location.pathname + '#' + encoded;
    const ok = await copyToClipboard(url);
    showShareFeedback(ok ? 'Link copied!' : 'Copy failed — try again.');
}

async function webShareEvent() {
    try {
        const encoded = encodeEvent(state.event);
        const url = location.origin + location.pathname + '#' + encoded;
        await navigator.share({
            title: state.event.title,
            text: state.event.description || 'Join this Conductor event!',
            url: url,
        });
    } catch (e) {
        // User cancelled or share failed — no feedback needed
    }
}

async function downloadBundledHTML() {
    const btn = $('btn-download-html');
    const origText = btn.textContent;
    btn.disabled = true;
    btn.textContent = 'Preparing...';
    try {
        const encoded = encodeEvent(state.event);

        // Fetch all script files
        const scriptTags = document.querySelectorAll('script[src]');
        const scriptContents = new Map();

        for (const tag of scriptTags) {
            const resp = await fetch(tag.getAttribute('src'));
            if (!resp.ok) throw new Error('Could not fetch ' + tag.getAttribute('src'));
            scriptContents.set(tag.getAttribute('src'), await resp.text());
        }

        // Get current page HTML
        let html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;

        // Replace script src tags with inline content
        const closeTag = '<' + '/script>';
        for (const [src, content] of scriptContents) {
            html = html.replace(
                new RegExp('<script\\s+src=["\']' + src.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '["\']\\s*>' + closeTag, 'i'),
                '<script>/* ' + src + ' */\n' + content + '\n' + closeTag
            );
        }

        // Remove manifest link (separate file, not bundled)
        html = html.replace(/<link[^>]*rel="manifest"[^>]*>\s*/i, '');

        // Remove SW registration (doesn't work on file://)
        html = html.replace(/\/\/ Register Service Worker[\s\S]*?navigator\.serviceWorker\.register\([^)]*\)[^}]*}\s*/g, '');

        // Inject event auto-load before closing body tag
        const closeBody = '<' + '/body>';
        const autoLoadScript = '<script>if(!location.hash)location.hash=\'' + encoded + '\';<' + '/script>';
        html = html.replace(closeBody, autoLoadScript + '\n' + closeBody);

        // Offer as download
        const blob = new Blob([html], { type: 'text/html' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = sanitizeFilename(state.event.title) + '.html';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showShareFeedback('Download started!');
    } catch (e) {
        showShareFeedback('Download failed — only works from hosted version.');
    } finally {
        btn.disabled = false;
        btn.textContent = origText;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// PACK MANAGER screen
// ═══════════════════════════════════════════════════════════════════════════

async function renderPackManager() {
    const listEl = $('pack-list');
    const emptyEl = $('pack-empty');
    const statusEl = $('import-status');
    statusEl.textContent = '';
    statusEl.className = 'import-status';

    listEl.innerHTML = '';

    const packs = await packManager.listPacks();

    if (packs.length === 0) {
        emptyEl.style.display = '';
        return;
    }

    emptyEl.style.display = 'none';

    for (const manifest of packs) {
        const cueCount = manifest.cues ? Object.keys(manifest.cues).length : 0;
        const card = document.createElement('div');
        card.className = 'pack-card';
        card.innerHTML = `
            <div class="pack-info">
                <div class="pack-name">${escapeHtml(manifest.name)}</div>
                <div class="pack-meta">v${escapeHtml(manifest.version || '1.0.0')} &middot; ${cueCount} cue${cueCount !== 1 ? 's' : ''}</div>
            </div>
            <button class="pack-delete" data-pack-id="${escapeHtml(manifest.id)}">Delete</button>
        `;
        listEl.appendChild(card);
    }
}

async function importPackFromFile(file) {
    const statusEl = $('import-status');
    statusEl.className = 'import-status progress';
    statusEl.textContent = 'Reading file...';

    try {
        const arrayBuffer = await file.arrayBuffer();
        const manifest = await packManager.importPack(arrayBuffer, (msg) => {
            statusEl.textContent = msg;
        });
        await packManager.ensurePackLoaded(manifest.id);
        statusEl.className = 'import-status success';
        statusEl.textContent = `Imported "${manifest.name}" (${Object.keys(manifest.cues).length} cues)`;
        renderPackManager();
    } catch (e) {
        statusEl.className = 'import-status error';
        statusEl.textContent = e.message || 'Import failed.';
    }
}

async function deletePackUI(packId) {
    if (!confirm('Delete this resource pack?')) return;

    try {
        await packManager.deletePack(packId);
        renderPackManager();
    } catch (e) {
        const statusEl = $('import-status');
        statusEl.className = 'import-status error';
        statusEl.textContent = 'Delete failed: ' + (e.message || 'unknown error');
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Event Bindings
// ═══════════════════════════════════════════════════════════════════════════

// Input screen
$('btn-load').addEventListener('click', () => {
    if (loadFromString($('input-paste').value)) {
        state.previewReturnTo = 'input';
        transitionTo('preview');
    }
});

$('btn-demo').addEventListener('click', () => {
    createDemoEvent();
    state.previewReturnTo = 'input';
    transitionTo('preview');
});

$('btn-import-event').addEventListener('click', () => {
    $('event-file-input').click();
});
$('event-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        file.text().then(text => {
            if (loadFromString(text)) {
                state.previewReturnTo = 'input';
                transitionTo('preview');
            }
        }).catch(err => {
            $('input-error').textContent = 'Could not read file: ' + err.message;
        });
        e.target.value = '';
    }
});

$('btn-create').addEventListener('click', () => {
    resetEditorState();
    transitionTo('editor-info');
});

// Preview screen
$('btn-start-practice').addEventListener('click', () => {
    transitionTo('practice');
});

$('btn-preview-back').addEventListener('click', () => {
    transitionTo(state.previewReturnTo);
});

// Practice screen
$('speed-slider').addEventListener('input', (e) => {
    // Re-anchor virtual time before changing speed to prevent time jumps
    const virtualNow = getPracticeNow(Date.now(), state.practiceStartRealMs,
        state.practiceStartEventMs, state.speedMultiplier);
    state.practiceStartRealMs = Date.now();
    state.practiceStartEventMs = virtualNow;
    state.speedMultiplier = parseFloat(e.target.value);
    $('speed-val').textContent = state.speedMultiplier + 'x';
});

$('btn-audio-toggle').addEventListener('click', toggleMute);

$('btn-go-live').addEventListener('click', () => {
    transitionTo('live');
});

$('btn-practice-stop').addEventListener('click', () => {
    transitionTo('preview');
});

// Live screen
$('btn-audio-toggle-live').addEventListener('click', toggleMute);

$('btn-live-stop').addEventListener('click', () => {
    transitionTo('preview');
});

// Completed screen
$('btn-return').addEventListener('click', () => {
    state.event = null;
    transitionTo('input');
});

// Editor — Step 1
$('btn-ed-next1').addEventListener('click', () => {
    if (saveEditorInfo()) {
        transitionTo('editor-timeline');
    }
});
$('btn-ed-cancel').addEventListener('click', () => {
    transitionTo('input');
});

// Editor — Step 2
$('btn-add-action').addEventListener('click', addNewAction);
$('btn-ed-next2').addEventListener('click', () => {
    if (state.editor.actions.length === 0 || state.editor.actions.some(a => !a.action)) {
        $('ed-timeline-error').textContent = 'Add at least one action with text.';
        return;
    }
    transitionTo('editor-review');
});
$('btn-ed-back1').addEventListener('click', () => {
    transitionTo('editor-info');
});

// Editor — Step 3 QR Code
function showQRCode() {
    const container = $('qr-container');
    const warning = $('qr-warning');
    const btn = $('btn-show-qr');

    // Toggle visibility
    if (container.style.display !== 'none') {
        container.style.display = 'none';
        btn.textContent = 'Show QR Code';
        return;
    }

    try {
        const encoded = encodeEvent(state.event);
        const fullUrl = location.origin + location.pathname + '#' + encoded;

        if (fullUrl.length > 2953) {
            warning.textContent = 'Event too large for QR code — use Copy or Share instead.';
            container.style.display = 'block';
            $('qr-canvas').style.display = 'none';
            btn.textContent = 'Hide QR Code';
            return;
        }

        warning.textContent = '';
        $('qr-canvas').style.display = '';
        QrCreator.render({
            text: fullUrl,
            radius: 0.4,
            ecLevel: 'M',
            fill: '#e0e0e0',
            background: '#1a1a2e',
            size: 220,
        }, $('qr-canvas'));

        container.style.display = 'block';
        btn.textContent = 'Hide QR Code';
    } catch (e) {
        warning.textContent = 'Could not generate QR code.';
        container.style.display = 'block';
        $('qr-canvas').style.display = 'none';
        btn.textContent = 'Hide QR Code';
    }
}

$('btn-show-qr').addEventListener('click', showQRCode);
$('btn-copy-code').addEventListener('click', copyEventCode);
$('btn-copy-link').addEventListener('click', copyShareableLink);
$('btn-web-share').addEventListener('click', webShareEvent);
$('btn-download-html').addEventListener('click', downloadBundledHTML);
$('btn-preview-from-editor').addEventListener('click', () => {
    state.previewReturnTo = 'editor-review';
    transitionTo('preview');
});
$('btn-ed-back2').addEventListener('click', () => {
    transitionTo('editor-timeline');
});

// Pack Manager
$('btn-manage-packs').addEventListener('click', () => {
    transitionTo('packs');
});
$('btn-import-pack').addEventListener('click', () => {
    $('pack-file-input').click();
});
$('pack-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importPackFromFile(file);
        e.target.value = ''; // reset so same file can be re-imported
    }
});
$('pack-list').addEventListener('click', (e) => {
    const btn = e.target.closest('.pack-delete');
    if (btn) {
        deletePackUI(btn.dataset.packId);
    }
});
$('btn-packs-back').addEventListener('click', () => {
    transitionTo('input');
});

// ═══════════════════════════════════════════════════════════════════════════
// Init: check URL hash on load
// ═══════════════════════════════════════════════════════════════════════════

window.addEventListener('hashchange', () => {
    if (loadFromHash()) {
        state.previewReturnTo = 'input';
        transitionTo('preview');
    }
});

// On page load
if (loadFromHash()) {
    state.previewReturnTo = 'input';
    transitionTo('preview');
}

// Register Service Worker (only works on HTTPS/localhost, silently skips file://)
if ('serviceWorker' in navigator && location.protocol !== 'file:') {
    navigator.serviceWorker.register('sw.js').catch(() => {});
}

</script>
</body>
</html>
