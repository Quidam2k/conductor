<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f0f23">
    <meta name="description" content="Synchronized coordination for real-world actions. No server, no app store, no accounts.">
    <meta property="og:title" content="Conductor">
    <meta property="og:description" content="Synchronized coordination for real-world actions. No server, no app store, no accounts.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://quidam2k.github.io/conductor/">
    <meta property="og:image" content="https://quidam2k.github.io/conductor/icon-512.png">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Conductor">
    <meta name="twitter:description" content="Synchronized coordination for real-world actions. No server, no app store, no accounts.">
    <meta name="twitter:image" content="https://quidam2k.github.io/conductor/icon-512.png">
    <meta name="apple-mobile-web-app-title" content="Conductor">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>Conductor</title>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            /* ─── Backgrounds (layered depth, darkest → lightest) ─── */
            --bg-deep: #08081a;
            --bg: #0f0f23;
            --bg-surface: #171733;
            --bg-elevated: #1f1f42;
            --bg-input: #0b0b1e;

            /* ─── Text (warm white, not cold blue-white) ─── */
            --text: #e8e6e3;
            --text-secondary: rgba(232, 230, 227, 0.7);
            --text-dim: rgba(232, 230, 227, 0.4);

            /* ─── Accent colors ─── */
            --accent-blue: #5ba3ff;
            --accent-green: #34d399;
            --accent-red: #ff4757;
            --accent-gold: #f0b429;
            --accent-purple: #a78bfa;

            /* ─── Glow effects (box-shadow values for hover/focus) ─── */
            --glow-blue: 0 0 20px rgba(91, 163, 255, 0.2);
            --glow-green: 0 0 20px rgba(52, 211, 153, 0.2);
            --glow-red: 0 0 20px rgba(255, 71, 87, 0.25);
            --glow-gold: 0 0 20px rgba(240, 180, 41, 0.2);
            --glow-purple: 0 0 20px rgba(167, 139, 250, 0.2);

            /* ─── Borders ─── */
            --border-subtle: rgba(255, 255, 255, 0.06);
            --border-medium: rgba(255, 255, 255, 0.12);

            /* ─── Radii ─── */
            --radius: 12px;
            --radius-sm: 8px;
            --radius-lg: 16px;
        }

        html, body {
            height: 100vh;
            height: 100dvh;
            background: var(--bg-deep);
            background: radial-gradient(ellipse at 50% 30%, var(--bg) 0%, var(--bg-deep) 70%);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }

        /* ─── Screen containers ─── */
        .screen {
            display: none;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            padding: 0;
        }
        .screen.active { display: flex; }

        /* ─── Header bar ─── */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            min-height: 52px;
            flex-shrink: 0;
        }
        .header h1 {
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .header-input   { background: linear-gradient(135deg, #0d1b3e, #0a1530); border-bottom: 1px solid rgba(91,163,255,0.08); }
        .header-preview { background: linear-gradient(135deg, #0d1b3e, #0a1530); border-bottom: 1px solid rgba(91,163,255,0.08); }
        .header-practice { background: linear-gradient(135deg, #0a2e1a, #071f12); border-bottom: 1px solid rgba(52,211,153,0.1); }
        .header-live     { background: linear-gradient(135deg, #3b0a0a, #2a0505); border-bottom: 1px solid rgba(255,71,87,0.12); }
        .header-done     { background: linear-gradient(135deg, #0d1b3e, #0a1530); border-bottom: 1px solid rgba(91,163,255,0.08); }

        .header .badge {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: 3px 10px;
            border-radius: 4px;
        }
        .badge-practice { background: var(--accent-green); color: #000; }
        .badge-live     { background: var(--accent-red); color: #fff; animation: pulse-badge 1.5s ease-in-out infinite; }

        @keyframes pulse-badge {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* ─── Content area ─── */
        .content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
        }

        /* ─── Buttons ─── */
        button {
            font-family: inherit;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            min-height: 48px;
            padding: 12px 24px;
            transition: opacity 0.15s, transform 0.1s, box-shadow 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        button:active { transform: scale(0.97); }
        button:focus:not(:focus-visible) { outline: none; }

        :focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: #fff;
            width: 100%;
        }
        .btn-green {
            background: var(--accent-green);
            color: #000;
            width: 100%;
        }
        .btn-red {
            background: var(--accent-red);
            color: #fff;
            width: 100%;
        }
        .btn-outline {
            background: transparent;
            color: var(--text-dim);
            border: 1px solid rgba(255,255,255,0.15);
            width: 100%;
        }
        .btn-small {
            min-height: 40px;
            font-size: 14px;
            padding: 8px 16px;
            width: auto;
        }

        .btn-row {
            display: flex;
            gap: 10px;
            width: 100%;
        }
        .btn-row button { flex: 1; }

        .btn-primary:hover, .btn-primary:focus-visible { box-shadow: var(--glow-blue); }
        .btn-green:hover, .btn-green:focus-visible { box-shadow: var(--glow-green); }
        .btn-red:hover, .btn-red:focus-visible { box-shadow: var(--glow-red); }
        .btn-outline:hover, .btn-outline:focus-visible { border-color: rgba(255,255,255,0.25); color: var(--text); }

        /* ─── Input screen ─── */
        .app-logo {
            text-align: center;
            margin: 24px 0 8px;
        }
        .app-logo h2 {
            font-size: 32px;
            font-weight: 800;
            letter-spacing: 4px;
        }
        .app-logo p {
            color: var(--text-secondary);
            font-size: 13px;
            margin-top: 4px;
        }
        .app-about {
            color: var(--text-dim);
            font-size: 13px;
            line-height: 1.5;
            text-align: center;
            margin: 0 8px 4px;
        }
        .app-about summary {
            cursor: pointer;
            font-size: 12px;
            color: var(--accent-blue);
            list-style: none;
            user-select: none;
        }
        .app-about summary::-webkit-details-marker { display: none; }
        .app-about .about-body {
            margin-top: 8px;
            text-align: left;
            padding: 0 4px;
        }
        .btn-hint {
            display: block;
            color: var(--text-dim);
            font-size: 11px;
            margin-top: 2px;
            text-align: center;
        }
        .pack-hint-input {
            font-size: 12px;
            color: var(--accent-gold);
            text-align: center;
            margin-top: 4px;
            margin-bottom: 4px;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: var(--radius);
            padding: 12px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
            margin: 12px 0;
        }
        textarea::placeholder { color: var(--text-dim); }
        textarea:focus { border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(91, 163, 255, 0.1); }
        textarea:focus:not(:focus-visible) { outline: none; }
        textarea:focus-visible { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(91, 163, 255, 0.15); }

        .error-msg {
            color: var(--accent-red);
            font-size: 13px;
            margin: 6px 0;
            min-height: 20px;
        }

        .separator {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
            color: var(--text-dim);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .separator::before, .separator::after {
            content: '';
            flex: 1;
            height: 1px;
            background: rgba(255,255,255,0.1);
        }

        /* ─── Preview screen ─── */
        .event-info {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius);
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .event-info h2 {
            font-size: 20px;
            margin-bottom: 6px;
        }
        .event-info .desc {
            color: var(--text-dim);
            font-size: 14px;
            margin-bottom: 12px;
        }
        .event-meta {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 4px 12px;
            font-size: 13px;
        }
        .event-meta dt { color: var(--text-dim); }
        .event-meta dd { color: var(--text); }

        .action-list {
            list-style: none;
            margin-top: 12px;
        }
        .action-list li {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 0 10px 10px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            border-left: 3px solid transparent;
            font-size: 14px;
        }
        .action-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .action-dot.normal   { background: var(--accent-blue); }
        .action-dot.emphasis { background: var(--accent-gold); }
        .action-dot.alert    { background: var(--accent-red); }
        .action-time {
            color: var(--text-dim);
            font-size: 12px;
            font-family: 'SF Mono', 'Cascadia Code', 'Consolas', 'Courier New', monospace;
            flex-shrink: 0;
            min-width: 48px;
        }

        /* ─── Briefing panel ─── */
        .briefing-panel {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius-sm);
            padding: 12px;
            margin: 8px 0;
            font-size: 13px;
            line-height: 1.4;
        }
        .briefing-panel dl { display: grid; grid-template-columns: auto 1fr; gap: 4px 12px; }
        .briefing-panel dt {
            font-weight: 600;
            color: var(--text-dim);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }
        .briefing-panel dd { margin: 0; margin-top: 4px; }
        .briefing-panel .briefing-role {
            font-weight: 600;
            font-size: 14px;
            color: var(--accent-blue);
        }
        .briefing-nav-btn {
            display: inline-block;
            padding: 8px 16px;
            margin: 4px 4px 0 0;
            background: var(--accent-blue);
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            min-height: 44px;
        }
        .briefing-nav-btn:active { opacity: 0.8; }
        .briefing-strip summary {
            cursor: pointer;
            padding: 8px 12px;
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: 6px;
            font-size: 13px;
            list-style: none;
            user-select: none;
            color: var(--text-secondary);
        }
        .briefing-strip summary::-webkit-details-marker { display: none; }
        .briefing-strip .briefing-panel { margin-top: 4px; }

        /* ─── Practice / Live screens ─── */
        .canvas-wrap {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
            padding: 8px;
        }
        .canvas-wrap canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            flex-shrink: 0;
            padding: 12px 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .speed-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .speed-row label {
            font-size: 13px;
            color: var(--text-dim);
            white-space: nowrap;
        }
        .speed-row input[type="range"] {
            flex: 1;
            accent-color: var(--accent-green);
            height: 28px;
        }
        .speed-val {
            font-size: 15px;
            font-weight: 700;
            font-family: 'SF Mono', 'Cascadia Code', 'Consolas', 'Courier New', monospace;
            min-width: 36px;
            text-align: right;
        }

        .icon-btn {
            min-height: 40px;
            min-width: 40px;
            padding: 6px;
            font-size: 20px;
            background: var(--bg-surface);
            border: 1px solid rgba(255,255,255,0.12);
            color: var(--text);
            border-radius: 8px;
        }
        .icon-btn:hover { box-shadow: var(--glow-blue); }
        .icon-btn.muted { opacity: 0.4; }

        /* ─── Completed screen ─── */
        .done-wrap {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 12px;
        }
        .done-wrap h2 {
            font-size: 24px;
            font-weight: 700;
        }
        .done-wrap p {
            color: var(--text-dim);
            font-size: 14px;
        }

        /* ─── Editor screens ─── */
        .header-editor { background: linear-gradient(135deg, #1a0d3e, #120830); border-bottom: 1px solid rgba(167,139,250,0.1); }

        .field-label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-dim);
            margin-bottom: 4px;
            margin-top: 14px;
        }
        .field-label:first-of-type { margin-top: 0; }
        .field-input, .field-textarea, .field-select {
            width: 100%;
            background: var(--bg-input);
            color: var(--text);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: var(--radius);
            padding: 10px 12px;
            font-family: inherit;
            font-size: 15px;
        }
        .field-textarea { min-height: 70px; resize: vertical; font-size: 14px; }
        .field-input:focus, .field-textarea:focus, .field-select:focus {
            border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(91, 163, 255, 0.1);
        }
        .field-input:focus:not(:focus-visible), .field-textarea:focus:not(:focus-visible), .field-select:focus:not(:focus-visible) { outline: none; }
        .field-input:focus-visible, .field-textarea:focus-visible, .field-select:focus-visible {
            outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(91, 163, 255, 0.15);
        }
        .field-select { appearance: auto; }

        .ed-action-list { list-style: none; display: flex; flex-direction: column; gap: 8px; margin-top: 12px; }
        .ed-action-card {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .ed-action-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
        }
        .ed-action-header .action-time { font-size: 13px; }
        .ed-action-header .action-name { flex: 1; font-size: 14px; }
        .ed-action-header .ed-btn-icon {
            background: none; border: none; color: var(--text-dim);
            font-size: 16px; min-height: 28px; min-width: 28px; padding: 2px;
            cursor: pointer;
        }
        .ed-action-header .ed-btn-icon:hover { color: var(--text); }

        .ed-action-edit {
            padding: 0 12px 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-top: 1px solid rgba(255,255,255,0.06);
        }
        .ed-offset-row {
            display: flex; align-items: center; gap: 6px; margin-top: 4px;
        }
        .ed-offset-row input {
            width: 60px; background: var(--bg-input); color: var(--text);
            border: 1px solid rgba(255,255,255,0.12); border-radius: 6px;
            padding: 6px 8px; font-size: 14px; text-align: center;
            font-family: inherit;
        }
        .ed-offset-row input:focus { border-color: var(--accent-blue); box-shadow: 0 0 0 3px rgba(91, 163, 255, 0.1); }
        .ed-offset-row input:focus:not(:focus-visible) { outline: none; }
        .ed-offset-row span { color: var(--text-dim); font-size: 13px; }

        .ed-toggle-group {
            display: flex; gap: 6px; flex-wrap: wrap;
        }
        .ed-toggle-btn {
            min-height: 34px; padding: 6px 12px; font-size: 13px; font-weight: 500;
            background: var(--bg-input); color: var(--text-dim);
            border: 1px solid rgba(255,255,255,0.12); border-radius: 6px;
            cursor: pointer;
        }
        .ed-toggle-btn.selected {
            border-color: var(--accent-blue); color: var(--accent-blue);
            background: rgba(74,158,255,0.1);
        }

        .ed-form-actions {
            display: flex; gap: 8px; margin-top: 4px;
        }
        .ed-form-actions button { flex: 1; min-height: 36px; font-size: 13px; }

        .btn-add-action {
            width: 100%; min-height: 44px; font-size: 14px;
            background: transparent; color: var(--text-dim);
            border: 2px dashed rgba(255,255,255,0.15); border-radius: var(--radius);
            cursor: pointer; margin-top: 8px;
        }
        .btn-add-action:hover { border-color: var(--accent-blue); color: var(--accent-blue); }

        .share-section {
            display: flex; flex-direction: column; gap: 10px; margin-top: 16px;
            background: var(--bg-surface); border: 1px solid var(--border-subtle);
            border-radius: var(--radius); padding: 16px;
        }
        .share-feedback {
            font-size: 13px; color: var(--accent-green);
            min-height: 20px; text-align: center;
            transition: opacity 0.3s;
        }

        .ed-checkbox-row {
            display: flex; align-items: center; gap: 8px;
        }
        .ed-checkbox-row input[type="checkbox"] {
            width: 18px; height: 18px; accent-color: var(--accent-blue);
        }
        .ed-checkbox-row label { font-size: 13px; color: var(--text-dim); }

        /* ─── Pack Manager screen ─── */
        .header-packs { background: linear-gradient(135deg, #1a2e0d, #121f08); border-bottom: 1px solid rgba(240,180,41,0.08); }

        .pack-list { list-style: none; display: flex; flex-direction: column; gap: 8px; }
        .pack-card {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: var(--radius);
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .pack-info { flex: 1; min-width: 0; }
        .pack-name {
            font-size: 15px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .pack-meta { font-size: 12px; color: var(--text-dim); margin-top: 2px; }
        .pack-url {
            font-size: 12px; margin-top: 4px; display: flex; align-items: center; gap: 6px;
        }
        .pack-url a { color: var(--accent-gold); text-decoration: underline; }
        .pack-copy-url {
            font-size: 11px; padding: 2px 8px; background: transparent;
            color: var(--text-dim); border: 1px solid var(--text-dim);
            border-radius: 4px; cursor: pointer;
        }
        .pack-delete {
            min-height: 34px; min-width: 34px; padding: 4px 10px;
            font-size: 13px; font-weight: 500;
            background: transparent; color: var(--accent-red);
            border: 1px solid var(--accent-red); border-radius: 6px;
            cursor: pointer; flex-shrink: 0;
        }
        .pack-delete:hover { box-shadow: var(--glow-red); }

        .pack-empty {
            text-align: center; padding: 32px 16px;
            color: var(--text-dim); font-size: 14px; line-height: 1.6;
        }
        .pack-hint {
            font-size: 13px; color: var(--accent-gold); padding: 10px 12px;
            background: rgba(255, 193, 7, 0.08); border-radius: var(--radius);
            margin-top: 12px; line-height: 1.5;
        }
        .pack-hint a { color: var(--accent-gold); text-decoration: underline; }

        .import-status {
            font-size: 13px; min-height: 20px; text-align: center;
            margin-top: 8px; transition: opacity 0.3s;
        }
        .import-status.error { color: var(--accent-red); }
        .import-status.success { color: var(--accent-green); }
        .import-status.progress { color: var(--accent-blue); }
        .import-status.warning { color: var(--accent-gold); }

        /* ─── Footer spacer for safe area ─── */
        .safe-bottom { height: env(safe-area-inset-bottom, 0px); flex-shrink: 0; }

        /* ─── Draft cards ─── */
        .draft-card { background:var(--bg-surface); border:1px solid var(--border-subtle); border-radius:var(--radius); padding:12px; margin-bottom:8px; display:flex; align-items:center; gap:10px; box-shadow:0 2px 8px rgba(0,0,0,0.3); }
        .draft-card-info { flex:1; min-width:0; }
        .draft-card-title { font-size:14px; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .draft-card-meta { font-size:12px; color:var(--text-dim); }
        .draft-card-actions { display:flex; gap:6px; flex-shrink:0; }
        .draft-saved-indicator { font-size:12px; color:var(--accent-green); text-align:center; margin-top:4px; opacity:0; transition:opacity 0.3s; }
        .draft-saved-indicator.visible { opacity:1; }

        /* ─── QR Scanner overlay ─── */
        .qr-overlay { position:fixed; inset:0; z-index:100; background:var(--bg); display:flex; flex-direction:column; }
        .qr-overlay-header { display:flex; align-items:center; justify-content:space-between; padding:12px 16px; background:#0d1b3e; }
        .qr-overlay-header h2 { font-size:18px; font-weight:600; }
        .qr-close-btn { min-height:40px; min-width:40px; font-size:24px; background:transparent; color:var(--text); border:none; cursor:pointer; }
        .qr-viewfinder { flex:1; position:relative; display:flex; align-items:center; justify-content:center; overflow:hidden; background:#000; }
        .qr-viewfinder video { width:100%; height:100%; object-fit:cover; }
        .qr-frame { position:absolute; width:240px; height:240px; border:2px solid var(--accent-blue); border-radius:16px; box-shadow:0 0 0 9999px rgba(0,0,0,0.4), 0 0 20px rgba(91,163,255,0.3); pointer-events:none; animation: qr-frame-glow 2s ease-in-out infinite; }
        @keyframes qr-frame-glow {
            0%, 100% { box-shadow: 0 0 0 9999px rgba(0,0,0,0.4), 0 0 15px rgba(91,163,255,0.2); }
            50% { box-shadow: 0 0 0 9999px rgba(0,0,0,0.4), 0 0 25px rgba(91,163,255,0.4); }
        }
        .qr-scan-status { text-align:center; padding:12px 16px; font-size:14px; color:var(--text-dim); }

        /* ─── QR Display overlay ─── */
        #qr-display-canvas { max-width:280px; max-height:280px; }

        /* ─── Screen transition animations ─── */
        @keyframes screen-slide-in {
            from { opacity: 0; transform: translateX(40px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes screen-slide-in-back {
            from { opacity: 0; transform: translateX(-40px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* ─── Micro-interaction keyframes ─── */
        @keyframes flash-success {
            0% { opacity: 0; transform: translateY(4px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-4px); }
            40%, 80% { transform: translateX(4px); }
        }
        .shake { animation: shake 0.3s ease-out; }
        @keyframes fade-in {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ─── Step indicator (for editor wizard) ─── */
        .step-dots { display: flex; gap: 6px; align-items: center; }
        .step-dot {
            width: 8px; height: 8px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: background 0.2s, box-shadow 0.2s;
        }
        .step-dot.active { background: var(--accent-purple); box-shadow: 0 0 8px rgba(167, 139, 250, 0.4); }
        .step-dot.completed { background: var(--accent-purple); }

        /* ─── Completed screen checkmark ─── */
        .done-check {
            width: 80px; height: 80px; border-radius: 50%;
            background: rgba(52, 211, 153, 0.15);
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 0 40px rgba(52, 211, 153, 0.1);
        }
        .done-check::after { content: '\2713'; font-size: 40px; color: var(--accent-green); }

        /* ─── Controls section top border (color-tinted per screen) ─── */
        #screen-practice .controls { border-top: 1px solid rgba(52, 211, 153, 0.15); }
        #screen-live .controls { border-top: 1px solid rgba(255, 71, 87, 0.2); }

        /* ─── Reduced motion ─── */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: INPUT                                                          -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-input" class="screen active">
    <div class="header header-input" role="banner">
        <h1>Conductor</h1>
    </div>
    <div class="content" role="main">
        <div class="app-logo">
            <h2>CONDUCTOR</h2>
            <p>Coordinate groups in real time with shared timed cues.<br>No accounts, no servers, no app required.</p>
        </div>

        <details class="app-about">
            <summary>What is this?</summary>
            <div class="about-body">
                Conductor coordinates groups of people using their phones. An organizer creates a timed sequence of cues — spoken announcements, vibrations, or audio — and shares it as a link or QR code. Every participant's device plays the same cues at the same time. No accounts, no app store, no server required.
            </div>
        </details>

        <textarea id="input-paste" placeholder="Got an event code? Paste it here..."></textarea>
        <div id="input-error" class="error-msg"></div>
        <button id="btn-load" class="btn-primary">Load Event</button>
        <button id="btn-scan-qr" class="btn-outline">Scan QR Code</button>

        <div id="drafts-section" style="display:none;">
            <h3 style="font-size:14px; color:var(--text-dim); margin:16px 0 8px;">My Drafts</h3>
            <div id="draft-list"></div>
        </div>

        <div class="separator">or</div>

        <button id="btn-create" class="btn-green">Create New Event</button>
        <button id="btn-demo" class="btn-outline">Load Demo Event</button>
        <span class="btn-hint">Try a sample event to see how it works</span>

        <div class="separator">or</div>

        <input type="file" id="event-file-input" accept=".json,.txt,.conductor" style="display:none;">
        <button id="btn-import-event" class="btn-outline">Import Event File</button>
        <button id="btn-manage-packs" class="btn-outline">Manage Packs</button>
        <div id="pack-hint-input" class="pack-hint-input" style="display:none;">Have a resource pack (.zip)? Tap above to import it.</div>
        <button id="btn-share-app" class="btn-outline">Share This App</button>

        <div style="flex:1"></div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: PACK MANAGER                                                   -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-packs" class="screen">
    <div class="header header-packs" role="banner">
        <h1>Pack Manager</h1>
    </div>
    <div class="content" role="main">
        <div id="pack-list" class="pack-list"></div>
        <div id="pack-empty" class="pack-empty">
            No packs installed.<br>
            Import a .zip resource pack<br>for higher-quality audio.
        </div>

        <div style="flex:1"></div>

        <input type="file" id="pack-file-input" accept=".zip" style="display:none;">
        <button id="btn-import-pack" class="btn-primary" style="margin-top:16px;">Import Pack (.zip)</button>
        <div id="import-status" class="import-status"></div>

        <button id="btn-packs-back" class="btn-outline" style="margin-top:10px;">Back</button>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: PREVIEW                                                        -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-preview" class="screen">
    <div class="header header-preview" role="banner">
        <h1>Event Preview</h1>
    </div>
    <div class="content" role="main">
        <div class="event-info">
            <h2 id="preview-title"></h2>
            <div id="preview-desc" class="desc"></div>
            <dl class="event-meta">
                <dt>Starts</dt>  <dd id="preview-start"></dd>
                <dt>Actions</dt> <dd id="preview-count"></dd>
                <dt>Duration</dt><dd id="preview-duration"></dd>
            </dl>
        </div>

        <div id="preview-briefing" class="briefing-panel" style="display:none"></div>

        <ul id="preview-actions" class="action-list"></ul>

        <div id="preview-pack-hint" class="pack-hint" style="display:none;"></div>

        <div style="flex:1"></div>

        <div style="display:flex; flex-direction:column; gap:10px; margin-top:16px;">
            <button id="btn-start-practice" class="btn-green">Start Practice</button>
            <div class="btn-row">
                <button id="btn-share-qr-preview" class="btn-primary" style="flex:2;">Share QR Code</button>
                <button id="btn-preview-back" class="btn-outline" style="flex:1;">Back</button>
            </div>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: PRACTICE                                                       -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-practice" class="screen">
    <div class="header header-practice" role="banner">
        <h1 id="practice-title">Practice</h1>
        <span class="badge badge-practice">PRACTICE</span>
    </div>
    <details id="practice-briefing" class="briefing-strip" style="display:none">
        <summary id="practice-briefing-summary">Briefing</summary>
        <div class="briefing-panel"></div>
    </details>
    <div class="canvas-wrap" role="main">
        <canvas id="canvas-practice"></canvas>
    </div>
    <div class="controls">
        <div class="speed-row">
            <label for="speed-slider">Speed</label>
            <input type="range" id="speed-slider" min="1" max="5" step="0.5" value="1" aria-label="Speed: 1x">
            <span id="speed-val" class="speed-val">1x</span>
        </div>
        <div class="btn-row">
            <button id="btn-audio-toggle" class="icon-btn" title="Toggle audio" aria-label="Toggle audio" aria-pressed="false">&#x1f50a;</button>
            <button id="btn-share-qr-practice" class="icon-btn" title="Share QR Code" aria-label="Share via QR code">&#x1f4e4;</button>
            <button id="btn-go-live" class="btn-red btn-small" style="flex:3">Go Live</button>
            <button id="btn-practice-stop" class="btn-outline btn-small">Stop</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: LIVE                                                           -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-live" class="screen">
    <div class="header header-live" role="banner">
        <h1 id="live-title">Live</h1>
        <span class="badge badge-live">LIVE</span>
    </div>
    <details id="live-briefing" class="briefing-strip" style="display:none">
        <summary id="live-briefing-summary">Briefing</summary>
        <div class="briefing-panel"></div>
    </details>
    <div class="canvas-wrap" role="main">
        <canvas id="canvas-live"></canvas>
    </div>
    <div class="controls">
        <div class="btn-row">
            <button id="btn-audio-toggle-live" class="icon-btn" title="Toggle audio" aria-label="Toggle audio" aria-pressed="false">&#x1f50a;</button>
            <button id="btn-live-stop" class="btn-outline btn-small" style="flex:3">Stop</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: COMPLETED                                                      -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-completed" class="screen">
    <div class="header header-done" role="banner">
        <h1>Conductor</h1>
    </div>
    <div class="content" role="main">
        <div class="done-wrap">
            <div class="done-check"></div>
            <h2>Event Completed</h2>
            <p id="done-summary"></p>
        </div>
        <button id="btn-return" class="btn-primary" style="margin-top:auto;">Return to Start</button>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: EDITOR — Event Info (Step 1)                                    -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-editor-info" class="screen">
    <div class="header header-editor" role="banner">
        <h1>New Event</h1>
        <span class="step-dots"><span class="step-dot active" aria-current="step"></span><span class="step-dot"></span><span class="step-dot"></span></span>
    </div>
    <div class="content" role="main">
        <label class="field-label">Event Title *</label>
        <input id="ed-title" class="field-input" type="text" placeholder="e.g. Flash Mob at Central Park" maxlength="80">

        <label class="field-label">Description</label>
        <textarea id="ed-description" class="field-textarea" placeholder="What is this event about?" maxlength="300"></textarea>

        <label class="field-label">Start Date & Time *</label>
        <input id="ed-datetime" class="field-input" type="datetime-local">

        <label class="field-label">Timezone</label>
        <select id="ed-timezone" class="field-select"></select>

        <div id="ed-info-error" class="error-msg" style="margin-top:10px;"></div>

        <div style="flex:1"></div>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:16px;">
            <button id="btn-ed-next1" class="btn-primary">Next: Timeline</button>
            <button id="btn-ed-cancel" class="btn-outline">Cancel</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: EDITOR — Timeline Builder (Step 2)                              -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-editor-timeline" class="screen">
    <div class="header header-editor" role="banner">
        <h1>Timeline</h1>
        <span class="step-dots"><span class="step-dot completed"></span><span class="step-dot active" aria-current="step"></span><span class="step-dot"></span></span>
    </div>
    <div class="content" role="main">
        <p style="font-size:13px; color:var(--text-dim); margin-bottom:8px;">
            Add actions with timing relative to the event start.
        </p>

        <div id="ed-action-list" class="ed-action-list"></div>
        <button id="btn-add-action" class="btn-add-action">+ Add Action</button>

        <div id="ed-timeline-error" class="error-msg" style="margin-top:10px;"></div>

        <div id="draft-saved-indicator" class="draft-saved-indicator">Draft saved</div>

        <div style="flex:1"></div>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:16px;">
            <button id="btn-ed-next2" class="btn-primary">Next: Review & Share</button>
            <button id="btn-save-draft" class="btn-outline">Save Draft</button>
            <button id="btn-ed-back1" class="btn-outline">Back</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- SCREEN: EDITOR — Review & Share (Step 3)                                -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="screen-editor-review" class="screen">
    <div class="header header-editor" role="banner">
        <h1>Review & Share</h1>
        <span class="step-dots"><span class="step-dot completed"></span><span class="step-dot completed"></span><span class="step-dot active" aria-current="step"></span></span>
    </div>
    <div class="content" role="main">
        <div class="event-info">
            <h2 id="review-title"></h2>
            <div id="review-desc" class="desc"></div>
            <dl class="event-meta">
                <dt>Starts</dt>  <dd id="review-start"></dd>
                <dt>Actions</dt> <dd id="review-count"></dd>
                <dt>Duration</dt><dd id="review-duration"></dd>
            </dl>
        </div>

        <ul id="review-actions" class="action-list"></ul>

        <div class="share-section">
            <div id="share-feedback" class="share-feedback"></div>
            <button id="btn-show-qr" class="btn-outline">Share QR Code</button>
            <button id="btn-copy-code" class="btn-primary">Copy Event Code</button>
            <button id="btn-copy-link" class="btn-primary">Copy Shareable Link</button>
            <button id="btn-web-share" class="btn-primary" style="display:none;">Share via...</button>
            <button id="btn-download-html" class="btn-outline">Share as File</button>
        </div>

        <div style="flex:1"></div>
        <div style="display:flex; flex-direction:column; gap:10px; margin-top:16px;">
            <button id="btn-preview-from-editor" class="btn-green">Preview Event</button>
            <button id="btn-ed-back2" class="btn-outline">Back</button>
        </div>
    </div>
    <div class="safe-bottom"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- OVERLAY: QR Scanner                                                     -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="qr-overlay" class="qr-overlay" style="display:none;" role="dialog" aria-modal="true" aria-labelledby="qr-scan-title">
    <div class="qr-overlay-header">
        <h2 id="qr-scan-title">Scan QR Code</h2>
        <button id="btn-qr-close" class="qr-close-btn" aria-label="Close scanner">&times;</button>
    </div>
    <div class="qr-viewfinder">
        <video id="qr-video" playsinline></video>
        <div class="qr-frame"></div>
    </div>
    <div id="qr-scan-status" class="qr-scan-status">Point camera at a QR code</div>
    <div id="qr-error" class="error-msg" style="text-align:center;"></div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- OVERLAY: QR Display (share via QR)                                      -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<div id="qr-display-overlay" class="qr-overlay" style="display:none;" role="dialog" aria-modal="true" aria-labelledby="qr-display-title">
    <div class="qr-overlay-header">
        <h2 id="qr-display-title">Share Event</h2>
        <button id="btn-qr-display-close" class="qr-close-btn" aria-label="Close QR display">&times;</button>
    </div>
    <div style="flex:1; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:16px; padding:16px;">
        <canvas id="qr-display-canvas" style="border-radius:8px;"></canvas>
        <div id="qr-display-warning" style="font-size:13px; color:var(--accent-gold); text-align:center; display:none;"></div>
        <p style="font-size:14px; color:var(--text-dim); text-align:center;">Scan this QR code with another phone to share this event.</p>
        <div class="btn-row" style="max-width:320px; width:100%;">
            <button id="btn-qr-display-copy-link" class="btn-primary btn-small" style="flex:1;">Copy Link</button>
            <button id="btn-qr-display-web-share" class="btn-primary btn-small" style="flex:1;">Share via...</button>
            <button id="btn-qr-display-share-file" class="btn-primary btn-small" style="flex:1;">Share File</button>
        </div>
    </div>
</div>

<!-- ════════════════════════════════════════════════════════════════════════ -->
<!-- Scripts                                                                 -->
<!-- ════════════════════════════════════════════════════════════════════════ -->
<script src="lib/pako.min.js"></script>
<script src="lib/qr-creator.min.js"></script>
<script src="lib/qr-scanner.legacy.min.js"></script>
<script src="js/models.js"></script>
<script src="js/eventEncoder.js"></script>
<script src="js/timingEngine.js"></script>
<script src="js/audioService.js"></script>
<script src="js/resourcePackManager.js"></script>
<script src="js/draftManager.js"></script>
<script src="js/circularTimeline.js"></script>

<script>
// ═══════════════════════════════════════════════════════════════════════════
// Global Error Handlers
// ═══════════════════════════════════════════════════════════════════════════

window.addEventListener('error', (e) => {
    console.error('Conductor error:', e.error);
});
window.addEventListener('unhandledrejection', (e) => {
    console.error('Conductor unhandled promise:', e.reason);
});

// ═══════════════════════════════════════════════════════════════════════════
// App State
// ═══════════════════════════════════════════════════════════════════════════

const state = {
    mode: 'input',              // 'input' | 'preview' | 'practice' | 'live' | 'completed' | 'editor-info' | 'editor-timeline' | 'editor-review' | 'packs'
    event: null,                // Full Event object
    speedMultiplier: 1,         // 1-5x (practice only)
    audioMuted: false,
    practiceStartRealMs: 0,     // Wall clock when practice started
    practiceStartEventMs: 0,    // Event time practice started from
    wakeLock: null,             // Wake Lock sentinel
    previewReturnTo: 'input',   // Where preview "Back" returns to
    qrScanner: null,            // QrScanner instance when scanning
    editor: {
        title: '',
        description: '',
        startDateTime: '',      // "YYYY-MM-DDTHH:MM" for datetime-local input
        timezone: '',           // IANA timezone string
        actions: [],            // Array of { offsetSeconds, action, style, hapticPattern, countdown, audioAnnounce }
        editingIndex: -1,       // Which action card has edit form open (-1 = none)
    },
};

// ═══════════════════════════════════════════════════════════════════════════
// Services (created once)
// ═══════════════════════════════════════════════════════════════════════════

const audio = createAudioService();
const packManager = createResourcePackManager();
const draftManager = createDraftManager();
let timelinePractice = null;    // CircularTimeline for practice canvas
let timelineLive = null;        // CircularTimeline for live canvas

// Wire resource pack resolver into audio service
audio.setResourcePackResolver(packManager.getResolver());

// Dev hook for console testing: window.importPack(arrayBuffer)
window.importPack = async (arrayBuffer) => {
    const manifest = await packManager.importPack(arrayBuffer, console.log);
    await packManager.ensurePackLoaded(manifest.id);
    console.log('Pack imported and loaded:', manifest.name, '— cues:', Object.keys(manifest.cues));
    return manifest;
};

// Loop handles
let rafId = null;
let audioIntervalId = null;

// ═══════════════════════════════════════════════════════════════════════════
// Focus Trap (for modal overlays)
// ═══════════════════════════════════════════════════════════════════════════

let _focusTrapCleanup = null;

function trapFocus(overlayEl) {
    releaseFocus();  // Clean up any existing trap
    const opener = document.activeElement;
    const focusable = overlayEl.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    if (!focusable.length) return;
    const first = focusable[0];
    const last = focusable[focusable.length - 1];
    first.focus();

    function onKeyDown(e) {
        if (e.key === 'Escape') {
            e.preventDefault();
            // Find and click the close button
            const closeBtn = overlayEl.querySelector('.qr-close-btn');
            if (closeBtn) closeBtn.click();
            return;
        }
        if (e.key !== 'Tab') return;
        if (e.shiftKey) {
            if (document.activeElement === first) { e.preventDefault(); last.focus(); }
        } else {
            if (document.activeElement === last) { e.preventDefault(); first.focus(); }
        }
    }

    overlayEl.addEventListener('keydown', onKeyDown);
    _focusTrapCleanup = () => {
        overlayEl.removeEventListener('keydown', onKeyDown);
        if (opener && opener.focus) opener.focus();
        _focusTrapCleanup = null;
    };
}

function releaseFocus() {
    if (_focusTrapCleanup) _focusTrapCleanup();
}

// ═══════════════════════════════════════════════════════════════════════════
// DOM references
// ═══════════════════════════════════════════════════════════════════════════

const $ = (id) => document.getElementById(id);
const screens = {
    'input':           $('screen-input'),
    'preview':         $('screen-preview'),
    'practice':        $('screen-practice'),
    'live':            $('screen-live'),
    'completed':       $('screen-completed'),
    'editor-info':     $('screen-editor-info'),
    'editor-timeline': $('screen-editor-timeline'),
    'editor-review':   $('screen-editor-review'),
    'packs':           $('screen-packs'),
};

// ═══════════════════════════════════════════════════════════════════════════
// Screen transitions
// ═══════════════════════════════════════════════════════════════════════════

const screenDepth = { 'input': 0, 'packs': 1, 'preview': 1, 'practice': 2, 'live': 3, 'completed': 4, 'editor-info': 1, 'editor-timeline': 2, 'editor-review': 3 };

function transitionTo(newMode) {
    const isBack = (screenDepth[newMode] || 0) < (screenDepth[state.mode] || 0);

    // 1. Stop any running loops
    stopLoops();

    // 2. Release wake lock if leaving practice/live
    if (state.mode === 'practice' || state.mode === 'live') {
        releaseWakeLock();
    }

    // 3. Hide all screens
    for (const s of Object.values(screens)) {
        s.classList.remove('active');
    }

    // 4. Show target + animate
    screens[newMode].classList.add('active');
    const content = screens[newMode].querySelector('.content') || screens[newMode];
    content.style.animation = 'none';
    void content.offsetHeight;
    content.style.animation = isBack ? 'screen-slide-in-back 0.25s ease-out' : 'screen-slide-in 0.25s ease-out';
    state.mode = newMode;

    // 5. Focus management — announce new screen to assistive tech
    const heading = screens[newMode].querySelector('h1');
    if (heading) {
        heading.setAttribute('tabindex', '-1');
        heading.focus();
    }

    // 6. Initialize mode-specific state
    switch (newMode) {
        case 'input':
            $('input-paste').value = '';
            $('input-error').textContent = '';
            renderDraftList();
            updatePackHint();
            break;

        case 'preview':
            renderPreview();
            break;

        case 'practice':
            enterPractice();
            break;

        case 'live':
            enterLive();
            break;

        case 'completed':
            renderCompleted();
            break;

        case 'editor-info':
            initEditorInfo();
            break;

        case 'editor-timeline':
            renderEditorTimeline();
            break;

        case 'editor-review':
            finalizeEditorEvent();
            renderEditorReview();
            break;

        case 'packs':
            renderPackManager();
            break;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// INPUT screen logic
// ═══════════════════════════════════════════════════════════════════════════

function loadFromString(input) {
    const trimmed = input.trim();
    if (!trimmed) {
        $('input-error').textContent = 'Please paste an event code, JSON, or text-format event.';
        return false;
    }
    try {
        const embedded = parseEventInput(trimmed);
        state.event = embeddedEventToEvent(embedded);
        return true;
    } catch (e) {
        $('input-error').textContent = e.message;
        return false;
    }
}

function loadFromHash() {
    const hash = location.hash.substring(1); // strip '#'
    if (!hash) return false;
    try {
        const embedded = parseEventInput(hash);
        state.event = embeddedEventToEvent(embedded);
        return true;
    } catch (e) {
        return false;
    }
}

function createDemoEvent() {
    const now = Date.now();
    const startMs = now + 10 * 1000; // 10 seconds from now
    const startTime = new Date(startMs).toISOString();

    const actions = [
        { offset: 0,   action: 'Get ready',        style: 'normal',   hapticPattern: 'single' },
        { offset: 15,  action: 'Wave left',         style: 'normal',   hapticPattern: 'double' },
        { offset: 30,  action: 'Wave right',        style: 'emphasis', hapticPattern: 'double' },
        { offset: 60,  action: 'Jump!',             style: 'alert',    hapticPattern: 'triple',
          countdownSeconds: [5, 4, 3, 2, 1] },
        { offset: 90,  action: 'Freeze in place',   style: 'emphasis', hapticPattern: 'double' },
    ];

    const timeline = actions.map(a => createTimelineAction({
        time: new Date(startMs + a.offset * 1000).toISOString(),
        action: a.action,
        style: a.style,
        hapticPattern: a.hapticPattern,
        countdownSeconds: a.countdownSeconds || null,
        noticeSeconds: 5,
    }));

    const embedded = {
        title: 'Demo Flash Mob',
        description: 'A quick demo event to test Conductor. Actions start in ~10 seconds.',
        startTime: startTime,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timeline: timeline,
    };

    state.event = embeddedEventToEvent(embedded);
}

// ═══════════════════════════════════════════════════════════════════════════
// QR Scanner
// ═══════════════════════════════════════════════════════════════════════════

function openQRScanner() {
    // Check for camera support
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        $('qr-error').textContent = 'Camera access requires HTTPS or localhost. Cannot scan from file:// URLs.';
        $('qr-overlay').style.display = 'flex';
        trapFocus($('qr-overlay'));
        return;
    }

    $('qr-error').textContent = '';
    $('qr-scan-status').textContent = 'Point camera at a QR code';
    $('qr-overlay').style.display = 'flex';
    trapFocus($('qr-overlay'));

    try {
        state.qrScanner = new QrScanner(
            $('qr-video'),
            result => handleQRResult(result.data),
            {
                returnDetailedScanResult: true,
                preferredCamera: 'environment',
                maxScansPerSecond: 5,
                onDecodeError: () => {},  // Suppress "no QR found" noise
            }
        );
        state.qrScanner.start().catch(err => {
            const msg = err && err.name === 'NotAllowedError'
                ? 'Camera permission denied. Please allow camera access and try again.'
                : err && err.name === 'NotFoundError'
                    ? 'No camera found on this device.'
                    : 'Could not start camera: ' + (err.message || err);
            $('qr-scan-status').textContent = '';
            $('qr-error').textContent = msg;
        });
    } catch (err) {
        $('qr-scan-status').textContent = '';
        $('qr-error').textContent = 'QR scanner not available: ' + (err.message || err);
    }
}

function closeQRScanner() {
    if (state.qrScanner) {
        state.qrScanner.stop();
        state.qrScanner.destroy();
        state.qrScanner = null;
    }
    $('qr-overlay').style.display = 'none';
    releaseFocus();
}

function handleQRResult(data) {
    let code = data;

    // If it's a URL, extract the hash fragment
    try {
        const url = new URL(data);
        if (url.hash && url.hash.length > 1) {
            code = url.hash.substring(1);  // Strip '#'
        }
    } catch {
        // Not a URL — treat as raw code
    }

    try {
        const embedded = parseEventInput(code);
        state.event = embeddedEventToEvent(embedded);
        closeQRScanner();
        state.previewReturnTo = 'input';
        transitionTo('preview');
    } catch {
        // Not a valid Conductor event — show error briefly, keep scanning
        $('qr-scan-status').textContent = 'Not a Conductor event — keep scanning';
        setTimeout(() => {
            if ($('qr-overlay').style.display !== 'none') {
                $('qr-scan-status').textContent = 'Point camera at a QR code';
            }
        }, 2000);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// BRIEFING panel
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Render briefing info into a container.
 * @param {Object|null} briefing - Briefing data object
 * @param {string} containerId - ID of the container element
 * @param {boolean} collapsible - If true, container is a <details> element
 */
function renderBriefing(briefing, containerId, collapsible) {
    const container = $(containerId);
    if (!container) return;

    if (!briefing || Object.keys(briefing).length === 0) {
        container.style.display = 'none';
        return;
    }

    const panel = collapsible ? container.querySelector('.briefing-panel') : container;
    let html = '<dl>';

    if (briefing.role) {
        html += '<dt>Role</dt><dd class="briefing-role">' + escapeHtml(briefing.role) + '</dd>';
    }
    if (briefing.event) {
        html += '<dt>Event</dt><dd>' + escapeHtml(briefing.event) + '</dd>';
    }
    if (briefing.exit) {
        html += '<dt>Exit</dt><dd>' + escapeHtml(briefing.exit);
        if (briefing.exitCoords) {
            html += ' <button class="briefing-nav-btn" onclick="openNavigation(\'' +
                escapeHtml(briefing.exitCoords) + '\', \'' + escapeHtml(briefing.exit) + '\')">Navigate</button>';
        }
        html += '</dd>';
    }
    if (briefing.rally) {
        html += '<dt>Rally</dt><dd>' + escapeHtml(briefing.rally);
        if (briefing.rallyCoords) {
            html += ' <button class="briefing-nav-btn" onclick="openNavigation(\'' +
                escapeHtml(briefing.rallyCoords) + '\', \'' + escapeHtml(briefing.rally) + '\')">Navigate</button>';
        }
        html += '</dd>';
    }
    if (briefing.abort) {
        html += '<dt>Abort</dt><dd>' + escapeHtml(briefing.abort) + '</dd>';
    }
    if (briefing.notes) {
        html += '<dt>Notes</dt><dd>' + escapeHtml(briefing.notes) + '</dd>';
    }

    html += '</dl>';
    panel.innerHTML = html;

    // Update summary text for collapsible
    if (collapsible) {
        const summary = container.querySelector('summary');
        if (summary && briefing.role) {
            summary.textContent = 'Briefing — ' + briefing.role;
        }
    }

    container.style.display = '';
}

/**
 * Open navigation to coordinates using platform-appropriate URL.
 * @param {string} coordsStr - "LAT, LNG" string
 * @param {string} label - Destination label
 */
function openNavigation(coordsStr, label) {
    const parts = coordsStr.split(',').map(s => s.trim());
    if (parts.length !== 2) return;
    const lat = parts[0], lng = parts[1];
    const encodedLabel = encodeURIComponent(label);

    const ua = navigator.userAgent;
    let url;
    if (/android/i.test(ua)) {
        // Android: geo URI triggers OS app chooser
        url = 'geo:' + lat + ',' + lng + '?q=' + lat + ',' + lng + '(' + encodedLabel + ')';
    } else if (/iPad|iPhone|iPod/.test(ua)) {
        // iOS: Apple Maps walking directions
        url = 'maps://?daddr=' + lat + ',' + lng + '&dirflg=w';
    } else {
        // Fallback: Google Maps web with walking directions
        url = 'https://www.google.com/maps/dir/?api=1&destination=' + lat + ',' + lng + '&travelmode=walking';
    }
    window.open(url, '_blank');
}

// ═══════════════════════════════════════════════════════════════════════════
// PREVIEW screen logic
// ═══════════════════════════════════════════════════════════════════════════

function renderPreview() {
    const evt = state.event;
    if (!evt) return;

    $('preview-title').textContent = evt.title;
    $('preview-desc').textContent = evt.description || '';
    $('preview-start').textContent = utcToLocalDisplay(evt.startTime, evt.timezone);
    $('preview-count').textContent = evt.timeline.length + ' actions';

    // Duration
    if (evt.timeline.length > 0) {
        const sorted = [...evt.timeline].sort((a, b) =>
            (a.timeMs ?? new Date(a.time).getTime()) - (b.timeMs ?? new Date(b.time).getTime())
        );
        const firstMs = sorted[0].timeMs ?? new Date(sorted[0].time).getTime();
        const lastMs = sorted[sorted.length - 1].timeMs ?? new Date(sorted[sorted.length - 1].time).getTime();
        const durationSec = Math.round((lastMs - firstMs) / 1000);
        const mins = Math.floor(durationSec / 60);
        const secs = durationSec % 60;
        $('preview-duration').textContent = mins > 0
            ? `${mins}m ${secs}s`
            : `${secs}s`;
    } else {
        $('preview-duration').textContent = '0s';
    }

    // Action list
    const list = $('preview-actions');
    list.innerHTML = '';
    const startMs = new Date(evt.startTime).getTime();

    for (const action of evt.timeline) {
        const actionMs = action.timeMs ?? new Date(action.time).getTime();
        const offsetSec = Math.round((actionMs - startMs) / 1000);
        const mins = Math.floor(offsetSec / 60);
        const secs = offsetSec % 60;

        const li = document.createElement('li');
        const borderColors = { normal: 'var(--accent-blue)', emphasis: 'var(--accent-gold)', alert: 'var(--accent-red)' };
        li.style.borderLeftColor = borderColors[action.style] || borderColors.normal;
        li.innerHTML = `
            <span class="action-dot ${action.style || 'normal'}"></span>
            <span class="action-time">${mins > 0 ? mins + ':' + String(secs).padStart(2,'0') : secs + 's'}</span>
            <span>${escapeHtml(action.action)}</span>
        `;
        list.appendChild(li);
    }

    // Briefing panel
    renderBriefing(evt.briefing, 'preview-briefing', false);

    // Pack hint: check for missing packs
    renderPackHint(evt);
}

async function renderPackHint(evt) {
    const hintEl = $('preview-pack-hint');
    hintEl.style.display = 'none';
    hintEl.innerHTML = '';

    const packIds = new Set();
    for (const action of evt.timeline) {
        if (action.pack) packIds.add(action.pack);
    }
    if (packIds.size === 0) return;

    const missing = [];
    for (const packId of packIds) {
        const has = await packManager.hasPack(packId);
        if (!has) missing.push(packId);
    }
    if (missing.length === 0) return;

    // Check if any installed pack has a URL matching a missing ID
    const allPacks = await packManager.listPacks();
    const urlMap = new Map();
    for (const m of allPacks) {
        if (m.url) urlMap.set(m.id, m.url);
    }

    let html = '';
    for (const packId of missing) {
        const urlForPack = urlMap.get(packId);
        html += `This event uses pack: <strong>${escapeHtml(packId)}</strong>. It works fine without it — packs add higher-quality audio.`;
        if (urlForPack) {
            html += ` <a href="${escapeHtml(urlForPack)}" target="_blank" rel="noopener">Get pack</a>`;
        }
        html += '<br>';
    }
    hintEl.innerHTML = html;
    hintEl.style.display = '';
}

// ═══════════════════════════════════════════════════════════════════════════
// PRACTICE mode
// ═══════════════════════════════════════════════════════════════════════════

function enterPractice() {
    const evt = state.event;
    if (!evt || evt.timeline.length === 0) return;

    $('practice-title').textContent = evt.title;
    renderBriefing(evt.briefing, 'practice-briefing', true);

    // Initialize audio on first user gesture
    if (!audio.isInitialized()) {
        audio.initialize();
    }
    audio.reset();
    audio.setMuted(state.audioMuted);

    // Pre-load resource packs referenced by event actions
    preloadEventPacks(evt);

    // Set practice start: begin 15s before first action
    const sorted = [...evt.timeline].sort((a, b) =>
        (a.timeMs ?? new Date(a.time).getTime()) - (b.timeMs ?? new Date(b.time).getTime())
    );
    const firstActionMs = sorted[0].timeMs ?? new Date(sorted[0].time).getTime();
    state.practiceStartRealMs = Date.now();
    state.practiceStartEventMs = firstActionMs - 15000;
    state.speedMultiplier = parseFloat($('speed-slider').value);

    // Create timeline renderer
    const canvas = $('canvas-practice');
    timelinePractice = createCircularTimeline(canvas);
    timelinePractice.setEvent(evt);
    timelinePractice.resize();

    // Start loops
    startPracticeLoop();
    startAudioLoop('practice');
    requestWakeLock();
}

function startPracticeLoop() {
    function frame() {
        if (state.mode !== 'practice') return;
        const virtualNow = getPracticeNow(
            Date.now(),
            state.practiceStartRealMs,
            state.practiceStartEventMs,
            state.speedMultiplier
        );
        timelinePractice.setNowMs(virtualNow);
        timelinePractice.render();
        rafId = requestAnimationFrame(frame);
    }
    rafId = requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════════════════════════
// LIVE mode
// ═══════════════════════════════════════════════════════════════════════════

function enterLive() {
    const evt = state.event;
    if (!evt || evt.timeline.length === 0) return;

    // If all actions are >5 minutes past, go straight to completed
    const now = Date.now();
    const allPast = evt.timeline.every(a => (now - (a.timeMs ?? new Date(a.time).getTime())) > 5 * 60 * 1000);
    if (allPast) {
        transitionTo('completed');
        return;
    }

    $('live-title').textContent = evt.title;
    renderBriefing(evt.briefing, 'live-briefing', true);

    // Initialize audio on first user gesture
    if (!audio.isInitialized()) {
        audio.initialize();
    }
    audio.reset();
    audio.setMuted(state.audioMuted);

    // Pre-load resource packs referenced by event actions
    preloadEventPacks(evt);

    // Create timeline renderer
    const canvas = $('canvas-live');
    timelineLive = createCircularTimeline(canvas);
    timelineLive.setEvent(evt);
    timelineLive.resize();

    // Start loops
    startLiveLoop();
    startAudioLoop('live');
    requestWakeLock();
}

function startLiveLoop() {
    function frame() {
        if (state.mode !== 'live') return;
        const now = Date.now();
        timelineLive.setNowMs(now);
        timelineLive.render();

        // Auto-complete: check if all actions are past
        checkCompletion(now);

        rafId = requestAnimationFrame(frame);
    }
    rafId = requestAnimationFrame(frame);
}

function checkCompletion(nowMs) {
    const evt = state.event;
    if (!evt) return;
    const endMs = new Date(evt.endTime).getTime();
    if (nowMs > endMs) {
        transitionTo('completed');
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Audio loop (shared by practice + live)
// ═══════════════════════════════════════════════════════════════════════════

function startAudioLoop(mode) {
    audioIntervalId = setInterval(() => {
        if (state.mode !== mode) return;

        const evt = state.event;
        if (!evt) return;

        const nowMs = (mode === 'practice')
            ? getPracticeNow(Date.now(), state.practiceStartRealMs,
                             state.practiceStartEventMs, state.speedMultiplier)
            : Date.now();

        const speedMult = (mode === 'practice') ? state.speedMultiplier : 1;

        for (const action of evt.timeline) {
            const secUntil = calculateTimeUntilPrecise(action, nowMs);

            // Only process actions within announcement range
            if (secUntil < -2 || secUntil > evt.defaultNoticeSeconds + 2) continue;

            const result = audio.announceAction(
                action, secUntil, evt.defaultNoticeSeconds, speedMult,
                {
                    defaultCountdownSeconds: evt.defaultCountdownSeconds,
                    defaultCountdown: evt.defaultCountdown,
                    defaultHapticMode: evt.defaultHapticMode,
                }
            );

            // Haptic feedback — respects event-level haptic mode
            const hapticMode = evt.defaultHapticMode || 'action';
            if (result && hapticMode !== 'off') {
                if (result.startsWith('trigger')) {
                    audio.haptic(action.hapticPattern || 'double');
                } else if (result.startsWith('countdown') && hapticMode === 'countdown') {
                    audio.haptic('single');
                }
            }
        }
    }, 100); // 10Hz
}

// ═══════════════════════════════════════════════════════════════════════════
// COMPLETED screen
// ═══════════════════════════════════════════════════════════════════════════

function renderCompleted() {
    const evt = state.event;
    if (!evt) return;
    $('done-summary').textContent = `"${evt.title}" — ${evt.timeline.length} actions completed.`;
}

// ═══════════════════════════════════════════════════════════════════════════
// Loop management
// ═══════════════════════════════════════════════════════════════════════════

function stopLoops() {
    if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
    }
    if (audioIntervalId) {
        clearInterval(audioIntervalId);
        audioIntervalId = null;
    }
    // Stop any speech in progress
    if (window.speechSynthesis) {
        speechSynthesis.cancel();
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Wake Lock
// ═══════════════════════════════════════════════════════════════════════════

async function requestWakeLock() {
    try {
        if ('wakeLock' in navigator) {
            state.wakeLock = await navigator.wakeLock.request('screen');
        }
    } catch (e) {
        // Wake lock can fail (e.g. low battery, not visible)
    }
}

function releaseWakeLock() {
    if (state.wakeLock) {
        state.wakeLock.release().catch(() => {});
        state.wakeLock = null;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// Page Visibility (re-acquire wake lock, pause/resume audio)
// ═══════════════════════════════════════════════════════════════════════════

document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
        // Re-request wake lock (released on page hide)
        if (state.mode === 'practice' || state.mode === 'live') {
            requestWakeLock();
        }
    }
});

// ═══════════════════════════════════════════════════════════════════════════
// Resize handling
// ═══════════════════════════════════════════════════════════════════════════

window.addEventListener('resize', () => {
    if (state.mode === 'practice' && timelinePractice) {
        timelinePractice.resize();
    }
    if (state.mode === 'live' && timelineLive) {
        timelineLive.resize();
    }
});

// ═══════════════════════════════════════════════════════════════════════════
// Audio mute toggle
// ═══════════════════════════════════════════════════════════════════════════

function updateMuteButtons() {
    const icon = state.audioMuted ? '\u{1F507}' : '\u{1F50A}';
    const cls = state.audioMuted ? 'icon-btn muted' : 'icon-btn';
    $('btn-audio-toggle').textContent = icon;
    $('btn-audio-toggle').className = cls;
    $('btn-audio-toggle').setAttribute('aria-pressed', String(state.audioMuted));
    $('btn-audio-toggle-live').textContent = icon;
    $('btn-audio-toggle-live').className = cls;
    $('btn-audio-toggle-live').setAttribute('aria-pressed', String(state.audioMuted));
}

function toggleMute() {
    state.audioMuted = !state.audioMuted;
    audio.setMuted(state.audioMuted);
    updateMuteButtons();
}

// ═══════════════════════════════════════════════════════════════════════════
// Utility
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Pre-load resource packs referenced by event actions.
 * Fires async — doesn't block mode entry; audio falls back to TTS if not ready.
 */
function preloadEventPacks(evt) {
    const packIds = new Set();
    for (const action of evt.timeline) {
        if (action.pack) packIds.add(action.pack);
    }
    for (const packId of packIds) {
        packManager.ensurePackLoaded(packId).catch(() => {});
    }
}

function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

async function copyToClipboard(text) {
    try {
        await navigator.clipboard.writeText(text);
        return true;
    } catch {
        // Fallback for HTTP / older browsers / file:// context
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.cssText = 'position:fixed;left:-9999px';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        return ok;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// EDITOR — Event Info (Step 1)
// ═══════════════════════════════════════════════════════════════════════════

const COMMON_TIMEZONES = [
    'Pacific/Honolulu', 'America/Anchorage', 'America/Los_Angeles',
    'America/Denver', 'America/Chicago', 'America/New_York',
    'America/Sao_Paulo', 'Atlantic/Reykjavik', 'Europe/London',
    'Europe/Paris', 'Europe/Berlin', 'Europe/Helsinki',
    'Africa/Cairo', 'Asia/Dubai', 'Asia/Kolkata',
    'Asia/Bangkok', 'Asia/Shanghai', 'Asia/Tokyo',
    'Australia/Sydney', 'Pacific/Auckland',
];

function resetEditorState() {
    state.editor = {
        title: '',
        description: '',
        startDateTime: '',
        timezone: '',
        actions: [],
        editingIndex: -1,
        draftId: null,
    };
}

function getDefaultDateTime() {
    const now = new Date();
    now.setMinutes(Math.ceil(now.getMinutes() / 5) * 5, 0, 0);
    now.setHours(now.getHours() + 1);
    // Format as YYYY-MM-DDTHH:MM in local time
    const y = now.getFullYear();
    const mo = String(now.getMonth() + 1).padStart(2, '0');
    const d = String(now.getDate()).padStart(2, '0');
    const h = String(now.getHours()).padStart(2, '0');
    const mi = String(now.getMinutes()).padStart(2, '0');
    return `${y}-${mo}-${d}T${h}:${mi}`;
}

function populateTimezoneSelect(selected) {
    const sel = $('ed-timezone');
    sel.innerHTML = '';
    for (const tz of COMMON_TIMEZONES) {
        const opt = document.createElement('option');
        opt.value = tz;
        opt.textContent = tz.replace(/_/g, ' ');
        if (tz === selected) opt.selected = true;
        sel.appendChild(opt);
    }
    // If user's timezone isn't in the list, add it
    if (selected && !COMMON_TIMEZONES.includes(selected)) {
        const opt = document.createElement('option');
        opt.value = selected;
        opt.textContent = selected.replace(/_/g, ' ');
        opt.selected = true;
        sel.insertBefore(opt, sel.firstChild);
    }
}

function initEditorInfo() {
    const ed = state.editor;
    $('ed-title').value = ed.title;
    $('ed-description').value = ed.description;
    $('ed-datetime').value = ed.startDateTime || getDefaultDateTime();
    const tz = ed.timezone || Intl.DateTimeFormat().resolvedOptions().timeZone;
    populateTimezoneSelect(tz);
    $('ed-info-error').textContent = '';
}

function saveEditorInfo() {
    const title = $('ed-title').value.trim();
    const datetime = $('ed-datetime').value;
    // Reset error state (fixes gold color getting stuck from past-time warning)
    $('ed-info-error').textContent = '';
    $('ed-info-error').style.color = '';
    if (!title) {
        $('ed-info-error').textContent = 'Title is required.';
        return false;
    }
    if (!datetime) {
        $('ed-info-error').textContent = 'Start date/time is required.';
        return false;
    }
    // Warn (not block) if start time is in the past
    try {
        const tz = $('ed-timezone').value;
        const utcStr = localDateTimeToUTC(datetime, tz);
        if (new Date(utcStr).getTime() < Date.now()) {
            $('ed-info-error').textContent = 'Note: start time is in the past.';
            $('ed-info-error').style.color = 'var(--accent-gold)';
        }
    } catch { /* timezone conversion can fail on exotic timezones, proceed anyway */ }

    state.editor.title = title;
    state.editor.description = $('ed-description').value.trim();
    state.editor.startDateTime = datetime;
    state.editor.timezone = $('ed-timezone').value;

    // Auto-save draft silently on Step 1 → Step 2 transition
    saveDraftFromEditor().catch(() => {});

    return true;
}

// ═══════════════════════════════════════════════════════════════════════════
// EDITOR — Timeline Builder (Step 2)
// ═══════════════════════════════════════════════════════════════════════════

function renderEditorTimeline() {
    const list = $('ed-action-list');
    list.innerHTML = '';
    $('ed-timeline-error').textContent = '';

    // Sort actions by offset
    state.editor.actions.sort((a, b) => a.offsetSeconds - b.offsetSeconds);

    state.editor.actions.forEach((action, index) => {
        const card = createActionCard(action, index);
        list.appendChild(card);
    });
}

function formatOffset(totalSec) {
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return m > 0 ? `${m}:${String(s).padStart(2, '0')}` : `${s}s`;
}

function createActionCard(action, index) {
    const card = document.createElement('div');
    card.className = 'ed-action-card';
    card.dataset.index = index;

    const header = document.createElement('div');
    header.className = 'ed-action-header';
    header.innerHTML = `
        <span class="action-dot ${action.style || 'normal'}"></span>
        <span class="action-time">${formatOffset(action.offsetSeconds)}</span>
        <span class="action-name">${escapeHtml(action.action)}</span>
        <button class="ed-btn-icon ed-btn-edit" title="Edit">&#9998;</button>
        <button class="ed-btn-icon ed-btn-delete" title="Delete">&#10005;</button>
    `;
    card.appendChild(header);

    // Show edit form if this card is being edited
    if (state.editor.editingIndex === index) {
        card.appendChild(createActionEditForm(action, index));
    }

    return card;
}

function createActionEditForm(action, index) {
    const form = document.createElement('div');
    form.className = 'ed-action-edit';

    const mins = Math.floor(action.offsetSeconds / 60);
    const secs = action.offsetSeconds % 60;

    form.innerHTML = `
        <label class="field-label" style="margin-top:8px;">Offset from start</label>
        <div class="ed-offset-row">
            <input type="number" class="ed-offset-min" value="${mins}" min="0" max="999" placeholder="0">
            <span>min</span>
            <input type="number" class="ed-offset-sec" value="${secs}" min="0" max="59" placeholder="0">
            <span>sec</span>
        </div>

        <label class="field-label">Action text *</label>
        <input type="text" class="field-input ed-action-text" value="${escapeHtml(action.action)}" placeholder="e.g. Wave left" maxlength="80">

        <label class="field-label">Style</label>
        <div class="ed-toggle-group ed-style-group">
            <button type="button" class="ed-toggle-btn${action.style === 'normal' ? ' selected' : ''}" data-val="normal">Normal</button>
            <button type="button" class="ed-toggle-btn${action.style === 'emphasis' ? ' selected' : ''}" data-val="emphasis">Emphasis</button>
            <button type="button" class="ed-toggle-btn${action.style === 'alert' ? ' selected' : ''}" data-val="alert">Alert</button>
        </div>

        <label class="field-label">Haptic</label>
        <div class="ed-toggle-group ed-haptic-group">
            <button type="button" class="ed-toggle-btn${action.hapticPattern === 'single' ? ' selected' : ''}" data-val="single">Single</button>
            <button type="button" class="ed-toggle-btn${action.hapticPattern === 'double' ? ' selected' : ''}" data-val="double">Double</button>
            <button type="button" class="ed-toggle-btn${action.hapticPattern === 'triple' ? ' selected' : ''}" data-val="triple">Triple</button>
        </div>

        <div class="ed-checkbox-row">
            <input type="checkbox" id="ed-countdown-${index}" class="ed-countdown-check" ${action.countdown ? 'checked' : ''}>
            <label for="ed-countdown-${index}">5-second countdown</label>
        </div>

        <label class="field-label">Resource Pack</label>
        <select class="field-select ed-pack-select">
            <option value="">None (TTS only)</option>
        </select>
        <select class="field-select ed-cue-select" style="display:none; margin-top:6px;">
            <option value="">Select a cue...</option>
        </select>
        <input type="text" class="field-input ed-fallback-text" placeholder="TTS fallback text" style="display:none; margin-top:6px;" value="${escapeHtml(action.fallbackText || action.action)}" maxlength="80">

        <div class="ed-form-actions">
            <button type="button" class="btn-primary btn-small ed-btn-save">Save</button>
            <button type="button" class="btn-outline btn-small ed-btn-form-cancel">Cancel</button>
        </div>
    `;

    // Populate pack dropdown async
    populatePackDropdown(form, action);

    return form;
}

async function populatePackDropdown(form, action) {
    const packSelect = form.querySelector('.ed-pack-select');
    const cueSelect = form.querySelector('.ed-cue-select');
    const fallbackInput = form.querySelector('.ed-fallback-text');

    try {
        const packs = await packManager.listPacks();
        for (const pack of packs) {
            const opt = document.createElement('option');
            opt.value = pack.id;
            opt.textContent = pack.name;
            if (action.pack === pack.id) opt.selected = true;
            packSelect.appendChild(opt);
        }

        // If action already has a pack, show cue dropdown
        if (action.pack) {
            await populateCueDropdown(cueSelect, action.pack, action.cue);
            cueSelect.style.display = '';
            fallbackInput.style.display = '';
        }
    } catch { /* IDB not available — leave default */ }

    // Wire pack change → populate cues
    packSelect.addEventListener('change', async () => {
        const packId = packSelect.value;
        if (!packId) {
            cueSelect.style.display = 'none';
            fallbackInput.style.display = 'none';
            cueSelect.innerHTML = '<option value="">Select a cue...</option>';
            return;
        }
        await populateCueDropdown(cueSelect, packId, null);
        cueSelect.style.display = '';
        fallbackInput.style.display = '';
    });
}

async function populateCueDropdown(cueSelect, packId, selectedCue) {
    cueSelect.innerHTML = '<option value="">Select a cue...</option>';
    const cues = await packManager.getCueList(packId);
    for (const cueId of cues) {
        const opt = document.createElement('option');
        opt.value = cueId;
        opt.textContent = cueId;
        if (cueId === selectedCue) opt.selected = true;
        cueSelect.appendChild(opt);
    }
}

// Event delegation for timeline editor actions
$('ed-action-list').addEventListener('click', (e) => {
    const card = e.target.closest('.ed-action-card');
    if (!card) return;
    const index = parseInt(card.dataset.index);

    // Toggle buttons (style / haptic)
    if (e.target.classList.contains('ed-toggle-btn')) {
        const group = e.target.closest('.ed-toggle-group');
        group.querySelectorAll('.ed-toggle-btn').forEach(b => b.classList.remove('selected'));
        e.target.classList.add('selected');
        return;
    }

    // Edit button
    if (e.target.closest('.ed-btn-edit')) {
        state.editor.editingIndex = (state.editor.editingIndex === index) ? -1 : index;
        renderEditorTimeline();
        return;
    }

    // Delete button
    if (e.target.closest('.ed-btn-delete')) {
        state.editor.actions.splice(index, 1);
        if (state.editor.editingIndex === index) state.editor.editingIndex = -1;
        else if (state.editor.editingIndex > index) state.editor.editingIndex--;
        renderEditorTimeline();
        return;
    }

    // Save action form
    if (e.target.closest('.ed-btn-save')) {
        const editForm = card.querySelector('.ed-action-edit');
        const actionText = editForm.querySelector('.ed-action-text').value.trim();
        if (!actionText) return; // silently refuse

        const minVal = parseInt(editForm.querySelector('.ed-offset-min').value) || 0;
        const secVal = parseInt(editForm.querySelector('.ed-offset-sec').value) || 0;
        const offset = Math.max(0, minVal * 60 + secVal);

        const styleBtn = editForm.querySelector('.ed-style-group .ed-toggle-btn.selected');
        const hapticBtn = editForm.querySelector('.ed-haptic-group .ed-toggle-btn.selected');
        const countdownCheck = editForm.querySelector('.ed-countdown-check');

        const packSelect = editForm.querySelector('.ed-pack-select');
        const cueSelect = editForm.querySelector('.ed-cue-select');
        const fallbackInput = editForm.querySelector('.ed-fallback-text');

        const packId = packSelect ? packSelect.value : '';
        const cueId = cueSelect ? cueSelect.value : '';
        const fallbackText = fallbackInput ? fallbackInput.value.trim() : '';

        state.editor.actions[index] = {
            offsetSeconds: offset,
            action: actionText,
            style: styleBtn ? styleBtn.dataset.val : 'normal',
            hapticPattern: hapticBtn ? hapticBtn.dataset.val : 'double',
            countdown: countdownCheck.checked,
            audioAnnounce: true,
            pack: packId || null,
            cue: cueId || null,
            fallbackText: (packId && cueId && fallbackText) ? fallbackText : null,
        };
        state.editor.editingIndex = -1;
        renderEditorTimeline();

        // Auto-save draft silently after action edit
        saveDraftFromEditor().catch(() => {});

        return;
    }

    // Cancel edit form
    if (e.target.closest('.ed-btn-form-cancel')) {
        // If this was a new empty action, remove it
        if (!state.editor.actions[index].action) {
            state.editor.actions.splice(index, 1);
        }
        state.editor.editingIndex = -1;
        renderEditorTimeline();
        return;
    }
});

function addNewAction() {
    const lastOffset = state.editor.actions.length > 0
        ? state.editor.actions[state.editor.actions.length - 1].offsetSeconds + 15
        : 0;
    state.editor.actions.push({
        offsetSeconds: lastOffset,
        action: '',
        style: 'normal',
        hapticPattern: 'double',
        countdown: false,
        audioAnnounce: true,
    });
    // Sort so the new action lands in the right spot
    state.editor.actions.sort((a, b) => a.offsetSeconds - b.offsetSeconds);
    // Find the index of the newly added action (the one with empty text)
    const newIndex = state.editor.actions.findIndex(a => a.action === '');
    state.editor.editingIndex = newIndex >= 0 ? newIndex : state.editor.actions.length - 1;
    renderEditorTimeline();
}

// ═══════════════════════════════════════════════════════════════════════════
// EDITOR — Review & Share (Step 3)
// ═══════════════════════════════════════════════════════════════════════════

function localDateTimeToUTC(localStr, timezone) {
    // localStr is "YYYY-MM-DDTHH:MM"
    // We need to interpret this as a time in the given timezone and convert to UTC
    const [datePart, timePart] = localStr.split('T');
    const [year, month, day] = datePart.split('-').map(Number);
    const [hour, minute] = timePart.split(':').map(Number);

    // Initial guess: create a Date from UTC and adjust
    let guess = new Date(Date.UTC(year, month - 1, day, hour, minute, 0));

    // Use Intl to find what the local time would be at our guess
    for (let i = 0; i < 3; i++) {
        const fmt = new Intl.DateTimeFormat('en-US', {
            timeZone: timezone,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', hour12: false,
        });
        const parts = {};
        for (const p of fmt.formatToParts(guess)) {
            parts[p.type] = parseInt(p.value);
        }
        // hour can be 24 in some locales meaning midnight
        if (parts.hour === 24) parts.hour = 0;

        const diffMin = (hour - parts.hour) * 60 + (minute - parts.minute);
        const diffDay = day - parts.day;

        if (diffMin === 0 && diffDay === 0) break;
        guess = new Date(guess.getTime() + (diffMin + diffDay * 24 * 60) * 60000);
    }

    return guess.toISOString();
}

function finalizeEditorEvent() {
    const ed = state.editor;
    const startUTC = localDateTimeToUTC(ed.startDateTime, ed.timezone);
    const startMs = new Date(startUTC).getTime();

    const timeline = ed.actions.map(a => createTimelineAction({
        time: new Date(startMs + a.offsetSeconds * 1000).toISOString(),
        action: a.action,
        style: a.style,
        hapticPattern: a.hapticPattern,
        countdownSeconds: a.countdown ? [5, 4, 3, 2, 1] : null,
        audioAnnounce: a.audioAnnounce,
        noticeSeconds: 5,
        pack: a.pack || null,
        cue: a.cue || null,
        fallbackText: a.fallbackText || null,
    }));

    const embedded = {
        title: ed.title,
        description: ed.description || null,
        startTime: startUTC,
        timezone: ed.timezone,
        timeline: timeline,
    };

    state.event = embeddedEventToEvent(embedded);
}

function renderEditorReview() {
    const evt = state.event;
    if (!evt) return;

    $('review-title').textContent = evt.title;
    $('review-desc').textContent = evt.description || '';
    $('review-start').textContent = utcToLocalDisplay(evt.startTime, evt.timezone);
    $('review-count').textContent = evt.timeline.length + ' actions';

    // Duration
    if (evt.timeline.length > 0) {
        const sorted = [...evt.timeline].sort((a, b) =>
            (a.timeMs ?? new Date(a.time).getTime()) - (b.timeMs ?? new Date(b.time).getTime())
        );
        const firstMs = sorted[0].timeMs ?? new Date(sorted[0].time).getTime();
        const lastMs = sorted[sorted.length - 1].timeMs ?? new Date(sorted[sorted.length - 1].time).getTime();
        const durationSec = Math.round((lastMs - firstMs) / 1000);
        const mins = Math.floor(durationSec / 60);
        const secs = durationSec % 60;
        $('review-duration').textContent = mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
    } else {
        $('review-duration').textContent = '0s';
    }

    // Action list
    const list = $('review-actions');
    list.innerHTML = '';
    const startMs = new Date(evt.startTime).getTime();

    for (const action of evt.timeline) {
        const actionMs = action.timeMs ?? new Date(action.time).getTime();
        const offsetSec = Math.round((actionMs - startMs) / 1000);
        const mins = Math.floor(offsetSec / 60);
        const secs = offsetSec % 60;

        const li = document.createElement('li');
        const borderColors = { normal: 'var(--accent-blue)', emphasis: 'var(--accent-gold)', alert: 'var(--accent-red)' };
        li.style.borderLeftColor = borderColors[action.style] || borderColors.normal;
        li.innerHTML = `
            <span class="action-dot ${action.style || 'normal'}"></span>
            <span class="action-time">${mins > 0 ? mins + ':' + String(secs).padStart(2, '0') : secs + 's'}</span>
            <span>${escapeHtml(action.action)}</span>
        `;
        list.appendChild(li);
    }

    // Show/hide Web Share button
    if (navigator.share) {
        $('btn-web-share').style.display = '';
    }

    // URL length warning
    try {
        const encoded = encodeEvent(evt);
        const fullUrl = location.origin + location.pathname + '#' + encoded;
        if (fullUrl.length > 2000) {
            $('share-feedback').textContent = 'Long URL — "Copy Event Code" recommended over link sharing.';
            $('share-feedback').style.color = 'var(--accent-gold)';
            $('share-feedback').style.opacity = '1';
            return;
        }
    } catch { /* encoding can fail on edge cases */ }

    $('share-feedback').textContent = '';
}

// ═══════════════════════════════════════════════════════════════════════════
// Sharing Functions
// ═══════════════════════════════════════════════════════════════════════════

function showShareFeedback(msg) {
    const el = $('share-feedback');
    el.style.color = '';
    el.textContent = msg;
    el.style.opacity = '1';
    setTimeout(() => { el.style.opacity = '0'; }, 2500);
}

function sanitizeFilename(name) {
    return name.replace(/[^a-zA-Z0-9_\- ]/g, '').trim().replace(/\s+/g, '-').substring(0, 50) || 'conductor-event';
}

async function copyEventCode() {
    const encoded = encodeEvent(state.event);
    const ok = await copyToClipboard(encoded);
    showShareFeedback(ok ? 'Event code copied!' : 'Copy failed — try again.');
}

async function copyShareableLink() {
    const encoded = encodeEvent(state.event);
    const url = location.origin + location.pathname + '#' + encoded;
    const ok = await copyToClipboard(url);
    showShareFeedback(ok ? 'Link copied!' : 'Copy failed — try again.');
}

async function webShareEvent() {
    try {
        const encoded = encodeEvent(state.event);
        const url = location.origin + location.pathname + '#' + encoded;
        await navigator.share({
            title: state.event.title,
            text: state.event.description || 'Join this Conductor event!',
            url: url,
        });
    } catch (e) {
        // User cancelled or share failed — no feedback needed
    }
}

async function buildBundledHTML(encoded) {
    // Fetch all script files
    const scriptTags = document.querySelectorAll('script[src]');
    const scriptContents = new Map();

    for (const tag of scriptTags) {
        const resp = await fetch(tag.getAttribute('src'));
        if (!resp.ok) throw new Error('Could not fetch ' + tag.getAttribute('src'));
        scriptContents.set(tag.getAttribute('src'), await resp.text());
    }

    // Get current page HTML
    let html = '<!DOCTYPE html>\n' + document.documentElement.outerHTML;

    // Replace script src tags with inline content
    const closeTag = '<' + '/script>';
    for (const [src, content] of scriptContents) {
        html = html.replace(
            new RegExp('<script\\s+src=["\']' + src.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '["\']\\s*>' + closeTag, 'i'),
            '<script>/* ' + src + ' */\n' + content + '\n' + closeTag
        );
    }

    // Remove manifest link (separate file, not bundled)
    html = html.replace(/<link[^>]*rel="manifest"[^>]*>\s*/i, '');

    // Remove SW registration (doesn't work on file://)
    html = html.replace(/\/\/ Register Service Worker[\s\S]*?navigator\.serviceWorker\.register\([^)]*\)[^}]*}\s*/g, '');

    // Inject event auto-load before closing body tag (only if encoded provided)
    if (encoded) {
        const closeBody = '<' + '/body>';
        const autoLoadScript = '<script>if(!location.hash)location.hash=\'' + encoded + '\';<' + '/script>';
        html = html.replace(closeBody, autoLoadScript + '\n' + closeBody);
    }

    return html;
}

async function shareBundleFile(includeEvent, triggerBtn) {
    const origText = triggerBtn ? triggerBtn.textContent : '';
    if (triggerBtn) { triggerBtn.disabled = true; triggerBtn.textContent = 'Preparing...'; }
    try {
        const encoded = includeEvent ? encodeEvent(state.event) : null;
        const html = await buildBundledHTML(encoded);
        const filename = includeEvent && state.event
            ? sanitizeFilename(state.event.title) + '.html'
            : 'conductor.html';
        const file = new File([html], filename, { type: 'text/html' });

        // Try native file sharing
        if (navigator.canShare && navigator.canShare({ files: [file] })) {
            await navigator.share({ files: [file] });
            return;
        }

        // Fallback: blob download
        const blob = new Blob([html], { type: 'text/html' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showShareFeedback('Download started!');
    } catch (e) {
        if (e.name !== 'AbortError') {
            showShareFeedback('Share failed — only works from hosted version.');
        }
    } finally {
        if (triggerBtn) { triggerBtn.disabled = false; triggerBtn.textContent = origText; }
    }
}

async function downloadBundledHTML() {
    const btn = $('btn-download-html');
    const origText = btn.textContent;
    btn.disabled = true;
    btn.textContent = 'Preparing...';
    try {
        const encoded = encodeEvent(state.event);
        const html = await buildBundledHTML(encoded);

        const blob = new Blob([html], { type: 'text/html' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = sanitizeFilename(state.event.title) + '.html';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        showShareFeedback('Download started!');
    } catch (e) {
        showShareFeedback('Download failed — only works from hosted version.');
    } finally {
        btn.disabled = false;
        btn.textContent = origText;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// PACK MANAGER screen
// ═══════════════════════════════════════════════════════════════════════════

async function updatePackHint() {
    const hint = $('pack-hint-input');
    if (!hint) return;
    const packs = await packManager.listPacks();
    hint.style.display = packs.length === 0 ? '' : 'none';
}

async function renderPackManager() {
    const listEl = $('pack-list');
    const emptyEl = $('pack-empty');
    const statusEl = $('import-status');
    statusEl.textContent = '';
    statusEl.className = 'import-status';

    listEl.innerHTML = '';

    const packs = await packManager.listPacks();

    if (packs.length === 0) {
        emptyEl.style.display = '';
        return;
    }

    emptyEl.style.display = 'none';

    for (const manifest of packs) {
        const cueCount = manifest.cues ? Object.keys(manifest.cues).length : 0;
        const card = document.createElement('div');
        card.className = 'pack-card';
        const urlHtml = manifest.url
            ? `<div class="pack-url"><a href="${escapeHtml(manifest.url)}" target="_blank" rel="noopener">Download link</a> <button class="pack-copy-url" data-url="${escapeHtml(manifest.url)}">Copy</button></div>`
            : '';
        card.innerHTML = `
            <div class="pack-info">
                <div class="pack-name">${escapeHtml(manifest.name)}</div>
                <div class="pack-meta">v${escapeHtml(manifest.version || '1.0.0')} &middot; ${cueCount} cue${cueCount !== 1 ? 's' : ''}</div>
                ${urlHtml}
            </div>
            <button class="pack-delete" data-pack-id="${escapeHtml(manifest.id)}">Delete</button>
        `;
        listEl.appendChild(card);
    }
}

async function importPackFromFile(file) {
    const statusEl = $('import-status');
    statusEl.className = 'import-status progress';
    statusEl.textContent = 'Reading file...';

    try {
        const arrayBuffer = await file.arrayBuffer();
        const { manifest, validation } = await packManager.importPackWithValidation(arrayBuffer, (msg) => {
            statusEl.textContent = msg;
        });
        await packManager.ensurePackLoaded(manifest.id);

        const cueCount = Object.keys(manifest.cues).length;
        let summary = `Imported "${manifest.name}" (${cueCount} cues`;
        if (manifest.events && manifest.events.length > 0) summary += `, ${manifest.events.length} events`;
        summary += ')';

        renderPackManager();

        if (validation && validation.uncovered.length > 0) {
            statusEl.className = 'import-status warning';
            const warns = validation.uncovered;
            let msg = summary + '\n\n';
            msg += `\u26A0 ${warns.length} action${warns.length === 1 ? '' : 's'} will fall back to TTS:\n`;
            for (const w of warns.slice(0, 5)) {
                msg += `  \u2022 "${w.action}" (${w.event} @ ${w.time})\n`;
            }
            if (warns.length > 5) {
                msg += `  ... and ${warns.length - 5} more`;
            }
            statusEl.textContent = msg;
            statusEl.style.whiteSpace = 'pre-wrap';
        } else {
            statusEl.className = 'import-status success';
            statusEl.textContent = summary;
            if (validation) {
                statusEl.textContent += ` \u2014 all ${validation.total} actions covered`;
            }
        }
    } catch (e) {
        statusEl.className = 'import-status error';
        statusEl.textContent = e.message || 'Import failed.';
    }
}

async function deletePackUI(packId) {
    if (!confirm('Delete this resource pack?')) return;

    try {
        await packManager.deletePack(packId);
        renderPackManager();
    } catch (e) {
        const statusEl = $('import-status');
        statusEl.className = 'import-status error';
        statusEl.textContent = 'Delete failed: ' + (e.message || 'unknown error');
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// DRAFTS — Save / Load / Delete / Auto-save
// ═══════════════════════════════════════════════════════════════════════════

async function renderDraftList() {
    const section = $('drafts-section');
    const listEl = $('draft-list');
    try {
        const drafts = await draftManager.listDrafts();
        if (drafts.length === 0) {
            listEl.innerHTML = '';
            section.style.display = 'none';
            return;
        }
        section.style.display = '';
        listEl.innerHTML = '';
        for (const draft of drafts) {
            const card = document.createElement('div');
            card.className = 'draft-card';
            const modified = draft.lastModified
                ? new Date(draft.lastModified).toLocaleString(undefined, { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' })
                : '';
            const actionCount = draft.actions ? draft.actions.length : 0;
            card.innerHTML = `
                <div class="draft-card-info">
                    <div class="draft-card-title">${escapeHtml(draft.title || 'Untitled')}</div>
                    <div class="draft-card-meta">${actionCount} action${actionCount !== 1 ? 's' : ''} &middot; ${escapeHtml(modified)}</div>
                </div>
                <div class="draft-card-actions">
                    <button class="btn-small btn-primary draft-load-btn" data-draft-id="${escapeHtml(draft.id)}">Load</button>
                    <button class="btn-small btn-outline draft-delete-btn" data-draft-id="${escapeHtml(draft.id)}" style="color:var(--accent-red); border-color:var(--accent-red);">Del</button>
                </div>
            `;
            listEl.appendChild(card);
        }
    } catch {
        section.style.display = 'none';
    }
}

async function loadDraft(id) {
    const draft = await draftManager.getDraft(id);
    if (!draft) return;
    state.editor.draftId = draft.id;
    state.editor.title = draft.title || '';
    state.editor.description = draft.description || '';
    state.editor.startDateTime = draft.startDateTime || '';
    state.editor.timezone = draft.timezone || '';
    state.editor.actions = (draft.actions || []).map(a => Object.assign({}, a));
    state.editor.editingIndex = -1;
    transitionTo('editor-info');
}

function collectDraftFromEditor() {
    return {
        id: state.editor.draftId || null,
        title: $('ed-title') ? $('ed-title').value.trim() : state.editor.title,
        description: $('ed-description') ? $('ed-description').value.trim() : state.editor.description,
        startDateTime: $('ed-datetime') ? $('ed-datetime').value : state.editor.startDateTime,
        timezone: $('ed-timezone') ? $('ed-timezone').value : state.editor.timezone,
        actions: state.editor.actions.map(a => Object.assign({}, a)),
    };
}

async function saveDraftFromEditor() {
    const draft = collectDraftFromEditor();
    const saved = await draftManager.saveDraft(draft);
    state.editor.draftId = saved.id;
    showDraftSavedIndicator();
    return saved;
}

function showDraftSavedIndicator() {
    const el = $('draft-saved-indicator');
    if (!el) return;
    el.classList.add('visible');
    setTimeout(() => el.classList.remove('visible'), 1500);
}

async function deleteDraftUI(id) {
    if (!confirm('Delete this draft?')) return;
    await draftManager.deleteDraft(id);
    await renderDraftList();
}

// ═══════════════════════════════════════════════════════════════════════════
// Event Bindings
// ═══════════════════════════════════════════════════════════════════════════

// Input screen
$('btn-load').addEventListener('click', () => {
    if (loadFromString($('input-paste').value)) {
        state.previewReturnTo = 'input';
        transitionTo('preview');
    }
});

$('btn-demo').addEventListener('click', () => {
    createDemoEvent();
    state.previewReturnTo = 'input';
    transitionTo('preview');
});

$('btn-import-event').addEventListener('click', () => {
    $('event-file-input').click();
});
$('event-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        file.text().then(text => {
            if (loadFromString(text)) {
                state.previewReturnTo = 'input';
                transitionTo('preview');
            }
        }).catch(err => {
            $('input-error').textContent = 'Could not read file: ' + err.message;
        });
        e.target.value = '';
    }
});

$('btn-scan-qr').addEventListener('click', openQRScanner);
$('btn-qr-close').addEventListener('click', closeQRScanner);

$('btn-create').addEventListener('click', () => {
    resetEditorState();
    transitionTo('editor-info');
});

// Preview screen
$('btn-start-practice').addEventListener('click', () => {
    transitionTo('practice');
});

$('btn-preview-back').addEventListener('click', () => {
    transitionTo(state.previewReturnTo);
});

// Practice screen
$('speed-slider').addEventListener('input', (e) => {
    // Re-anchor virtual time before changing speed to prevent time jumps
    const virtualNow = getPracticeNow(Date.now(), state.practiceStartRealMs,
        state.practiceStartEventMs, state.speedMultiplier);
    state.practiceStartRealMs = Date.now();
    state.practiceStartEventMs = virtualNow;
    state.speedMultiplier = parseFloat(e.target.value);
    $('speed-val').textContent = state.speedMultiplier + 'x';
    $('speed-slider').setAttribute('aria-label', `Speed: ${state.speedMultiplier}x`);
});

$('btn-audio-toggle').addEventListener('click', toggleMute);

$('btn-go-live').addEventListener('click', () => {
    transitionTo('live');
});

$('btn-practice-stop').addEventListener('click', () => {
    transitionTo('preview');
});

// Live screen
$('btn-audio-toggle-live').addEventListener('click', toggleMute);

$('btn-live-stop').addEventListener('click', () => {
    if (!confirm('Stop the live event? This cannot be undone.')) return;
    transitionTo('preview');
});

// Completed screen
$('btn-return').addEventListener('click', () => {
    state.event = null;
    transitionTo('input');
});

// Editor — Step 1
$('btn-ed-next1').addEventListener('click', () => {
    if (saveEditorInfo()) {
        transitionTo('editor-timeline');
    }
});
$('btn-ed-cancel').addEventListener('click', () => {
    const hasData = $('ed-title').value.trim() || $('ed-description').value.trim();
    if (hasData && !confirm('Discard this event? Unsaved changes will be lost.')) return;
    transitionTo('input');
});

// Editor — Step 2
$('btn-add-action').addEventListener('click', addNewAction);
$('btn-ed-next2').addEventListener('click', () => {
    if (state.editor.actions.length === 0 || state.editor.actions.some(a => !a.action)) {
        $('ed-timeline-error').textContent = 'Add at least one action with text.';
        return;
    }
    transitionTo('editor-review');
});
$('btn-ed-back1').addEventListener('click', () => {
    transitionTo('editor-info');
});

// Editor — Save Draft
$('btn-save-draft').addEventListener('click', () => {
    saveDraftFromEditor();
});

// Drafts — click delegation for load/delete
$('draft-list').addEventListener('click', (e) => {
    const loadBtn = e.target.closest('.draft-load-btn');
    if (loadBtn) {
        loadDraft(loadBtn.dataset.draftId);
        return;
    }
    const delBtn = e.target.closest('.draft-delete-btn');
    if (delBtn) {
        deleteDraftUI(delBtn.dataset.draftId);
    }
});

// QR Display Overlay
function showQRDisplay() {
    const overlay = $('qr-display-overlay');
    const canvas = $('qr-display-canvas');
    const warning = $('qr-display-warning');
    const title = $('qr-display-title');

    title.textContent = state.event ? state.event.title : 'Share Event';

    // Hide web share button if not supported
    const webShareBtn = $('btn-qr-display-web-share');
    webShareBtn.style.display = navigator.share ? '' : 'none';

    // Hide share file button if share API not supported at all
    const shareFileBtn = $('btn-qr-display-share-file');
    shareFileBtn.style.display = (navigator.share || navigator.canShare) ? '' : 'none';

    try {
        const encoded = encodeEvent(state.event);
        const fullUrl = location.origin + location.pathname + '#' + encoded;

        if (fullUrl.length > 2953) {
            warning.textContent = 'Event too large for QR code — use Copy Link or Share instead.';
            warning.style.display = '';
            canvas.style.display = 'none';
        } else {
            warning.style.display = 'none';
            canvas.style.display = '';
            QrCreator.render({
                text: fullUrl,
                radius: 0.4,
                ecLevel: 'M',
                fill: '#e0e0e0',
                background: '#1a1a2e',
                size: 260,
            }, canvas);
        }
    } catch (e) {
        warning.textContent = 'Could not generate QR code.';
        warning.style.display = '';
        canvas.style.display = 'none';
    }

    overlay.style.display = 'flex';
    trapFocus(overlay);
}

function closeQRDisplay() {
    $('qr-display-overlay').style.display = 'none';
    releaseFocus();
}

$('btn-show-qr').addEventListener('click', showQRDisplay);
$('btn-share-qr-preview').addEventListener('click', showQRDisplay);
$('btn-share-qr-practice').addEventListener('click', showQRDisplay);
$('btn-qr-display-close').addEventListener('click', closeQRDisplay);
$('btn-qr-display-copy-link').addEventListener('click', async () => {
    const encoded = encodeEvent(state.event);
    const url = location.origin + location.pathname + '#' + encoded;
    const ok = await copyToClipboard(url);
    const btn = $('btn-qr-display-copy-link');
    const orig = btn.textContent;
    btn.textContent = ok ? 'Copied!' : 'Failed';
    setTimeout(() => { btn.textContent = orig; }, 1500);
});
$('btn-qr-display-web-share').addEventListener('click', async () => {
    try {
        const encoded = encodeEvent(state.event);
        const url = location.origin + location.pathname + '#' + encoded;
        await navigator.share({
            title: state.event.title,
            text: state.event.description || 'Join this Conductor event!',
            url: url,
        });
    } catch (e) {
        // User cancelled or share failed
    }
});
$('btn-qr-display-share-file').addEventListener('click', function() {
    shareBundleFile(true, this);
});
$('btn-copy-code').addEventListener('click', copyEventCode);
$('btn-copy-link').addEventListener('click', copyShareableLink);
$('btn-web-share').addEventListener('click', webShareEvent);
$('btn-download-html').addEventListener('click', function() { shareBundleFile(true, this); });
$('btn-preview-from-editor').addEventListener('click', () => {
    state.previewReturnTo = 'editor-review';
    transitionTo('preview');
});
$('btn-ed-back2').addEventListener('click', () => {
    transitionTo('editor-timeline');
});

// Pack Manager
$('btn-manage-packs').addEventListener('click', () => {
    transitionTo('packs');
});
$('btn-share-app').addEventListener('click', function() {
    shareBundleFile(false, this);
});
$('btn-import-pack').addEventListener('click', () => {
    $('pack-file-input').click();
});
$('pack-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        importPackFromFile(file);
        e.target.value = ''; // reset so same file can be re-imported
    }
});
$('pack-list').addEventListener('click', async (e) => {
    const delBtn = e.target.closest('.pack-delete');
    if (delBtn) {
        deletePackUI(delBtn.dataset.packId);
        return;
    }
    const copyBtn = e.target.closest('.pack-copy-url');
    if (copyBtn) {
        const ok = await copyToClipboard(copyBtn.dataset.url);
        const orig = copyBtn.textContent;
        copyBtn.textContent = ok ? 'Copied!' : 'Failed';
        setTimeout(() => { copyBtn.textContent = orig; }, 1500);
    }
});
$('btn-packs-back').addEventListener('click', () => {
    transitionTo('input');
});

// ═══════════════════════════════════════════════════════════════════════════
// Init: check URL hash on load
// ═══════════════════════════════════════════════════════════════════════════

window.addEventListener('hashchange', () => {
    if (loadFromHash()) {
        state.previewReturnTo = 'input';
        transitionTo('preview');
    }
});

// On page load
if (loadFromHash()) {
    state.previewReturnTo = 'input';
    transitionTo('preview');
} else {
    // On input screen by default — render draft list + pack hint
    renderDraftList();
    updatePackHint();
}

// Register Service Worker (only works on HTTPS/localhost, silently skips file://)
if ('serviceWorker' in navigator && location.protocol !== 'file:') {
    navigator.serviceWorker.register('sw.js').catch(() => {});
}

</script>
</body>
</html>
