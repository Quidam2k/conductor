<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conductor - Encoder/Decoder Tests</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: monospace; background: #1a1a2e; color: #e0e0e0; padding: 20px; line-height: 1.5; }
        h1 { color: #00d4ff; margin-bottom: 10px; }
        h2 { color: #ffa500; margin: 20px 0 8px; }
        .summary { font-size: 1.2em; margin: 10px 0 20px; padding: 10px; border-radius: 6px; }
        .summary.pass { background: #0a3d0a; border: 1px solid #0f0; }
        .summary.fail { background: #3d0a0a; border: 1px solid #f00; }
        .test { padding: 6px 10px; margin: 2px 0; border-radius: 4px; }
        .test.pass { background: #0a2d0a; }
        .test.fail { background: #2d0a0a; }
        .pass .icon::before { content: "PASS "; color: #0f0; font-weight: bold; }
        .fail .icon::before { content: "FAIL "; color: #f00; font-weight: bold; }
        .stats { background: #16213e; padding: 12px; border-radius: 6px; margin: 10px 0; }
        .stats dt { color: #888; float: left; width: 200px; }
        .stats dd { margin-left: 210px; color: #00d4ff; }
        pre { background: #0d1117; padding: 10px; border-radius: 4px; overflow-x: auto; margin: 6px 0; font-size: 0.85em; max-height: 300px; overflow-y: auto; }
        .encoded-str { word-break: break-all; color: #7ee787; }
    </style>
</head>
<body>
    <h1>Conductor â€” Encoder/Decoder Tests</h1>
    <div id="summary" class="summary">Running tests...</div>
    <div id="results"></div>

    <script src="lib/pako.min.js"></script>
    <script src="js/models.js"></script>
    <script src="js/eventEncoder.js"></script>
    <script>
    (function() {
        const results = document.getElementById('results');
        let passed = 0;
        let failed = 0;

        function log(html) {
            results.innerHTML += html;
        }

        function assert(testName, condition, detail) {
            if (condition) {
                passed++;
                log(`<div class="test pass"><span class="icon"></span>${testName}</div>`);
            } else {
                failed++;
                log(`<div class="test fail"><span class="icon"></span>${testName}` +
                    (detail ? `<pre>${esc(detail)}</pre>` : '') + `</div>`);
            }
        }

        function esc(str) {
            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }

        function deepEqual(a, b) {
            if (a === b) return true;
            if (a == null && b == null) return true;
            if (a == null || b == null) return false;
            if (typeof a !== typeof b) return false;
            if (Array.isArray(a)) {
                if (!Array.isArray(b) || a.length !== b.length) return false;
                return a.every((v, i) => deepEqual(v, b[i]));
            }
            if (typeof a === 'object') {
                const keysA = Object.keys(a).filter(k => a[k] !== null && a[k] !== undefined);
                const keysB = Object.keys(b).filter(k => b[k] !== null && b[k] !== undefined);
                if (keysA.length !== keysB.length) return false;
                return keysA.every(k => deepEqual(a[k], b[k]));
            }
            return false;
        }

        // â”€â”€â”€ Create sample event â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        const now = new Date();
        const startTime = new Date(now.getTime() + 60 * 60 * 1000).toISOString(); // 1 hour from now

        function makeAction(offsetSeconds, actionText, extras = {}) {
            const t = new Date(new Date(startTime).getTime() + offsetSeconds * 1000);
            return createTimelineAction({
                action: actionText,
                time: t.toISOString(),
                relativeTime: offsetSeconds,
                ...extras,
            });
        }

        const sampleActions = [
            makeAction(0, 'Everyone gather at the fountain', {
                style: 'emphasis',
                noticeSeconds: 10,
                countdownSeconds: [5, 4, 3, 2, 1],
                color: '#FFD700',
                icon: 'ğŸ“',
            }),
            makeAction(30, 'Start humming in unison', {
                cue: 'hum-start',
                fallbackText: 'Start humming now',
                pack: 'flash-mob-v1',
            }),
            makeAction(60, 'Raise your hands slowly', {
                style: 'alert',
                hapticPattern: 'triple',
            }),
            makeAction(90, 'Play random harmony part', {
                randomCues: ['harmony-a', 'harmony-b', 'harmony-c'],
                fallbackText: 'Hum your favorite note',
                pack: 'flash-mob-v1',
            }),
            makeAction(120, 'Freeze!', {
                style: 'alert',
                noticeSeconds: 5,
                countdownSeconds: [3, 2, 1],
            }),
        ];

        const sampleEvent = embeddedEventToEvent({
            title: 'Flash Mob at Central Park',
            description: 'A synchronized flash mob event with music and harmony.',
            startTime: startTime,
            timezone: 'America/New_York',
            timeline: sampleActions,
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 1: Basic round-trip
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>1. Basic Round-Trip Encode/Decode</h2>');

        let encoded;
        try {
            encoded = encodeEvent(sampleEvent);
            assert('encodeEvent() returns a string', typeof encoded === 'string');
            assert('Encoded string starts with "v1_"', encoded.startsWith('v1_'));
            assert('Encoded string is URL-safe (no +, /, =)', !/[+/=]/.test(encoded));
            log(`<pre class="encoded-str">${esc(encoded)}</pre>`);
        } catch (e) {
            assert('encodeEvent() did not throw', false, e.message);
        }

        let decoded;
        try {
            decoded = decodeEvent(encoded);
            assert('decodeEvent() returns an object', typeof decoded === 'object' && decoded !== null);
            assert('Title matches', decoded.title === sampleEvent.title);
            assert('Description matches', decoded.description === sampleEvent.description);
            assert('Start time matches', decoded.startTime === sampleEvent.startTime);
            assert('Timezone matches', decoded.timezone === sampleEvent.timezone);
            assert('Timeline length matches', decoded.timeline.length === sampleEvent.timeline.length);
        } catch (e) {
            assert('decodeEvent() did not throw', false, e.message);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 2: Field-by-field comparison
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>2. Field-by-Field Action Comparison</h2>');

        if (decoded && decoded.timeline) {
            for (let i = 0; i < sampleActions.length; i++) {
                const orig = sampleActions[i];
                const dec = decoded.timeline[i];

                assert(`Action[${i}] action text`, orig.action === dec.action,
                    `Expected "${orig.action}", got "${dec.action}"`);
                assert(`Action[${i}] time`, orig.time === dec.time,
                    `Expected "${orig.time}", got "${dec.time}"`);
                assert(`Action[${i}] relativeTime`, orig.relativeTime === dec.relativeTime);
                assert(`Action[${i}] style`, orig.style === dec.style);
                assert(`Action[${i}] audioAnnounce`, orig.audioAnnounce === dec.audioAnnounce);
                assert(`Action[${i}] hapticPattern`, orig.hapticPattern === dec.hapticPattern);

                // Nullable fields
                if (orig.noticeSeconds != null)
                    assert(`Action[${i}] noticeSeconds`, orig.noticeSeconds === dec.noticeSeconds);
                if (orig.countdownSeconds != null)
                    assert(`Action[${i}] countdownSeconds`, deepEqual(orig.countdownSeconds, dec.countdownSeconds),
                        `Expected [${orig.countdownSeconds}], got [${dec.countdownSeconds}]`);
                if (orig.color != null)
                    assert(`Action[${i}] color`, orig.color === dec.color);
                if (orig.icon != null)
                    assert(`Action[${i}] icon`, orig.icon === dec.icon);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 3: Resource pack fields survive encoding
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>3. Resource Pack Fields</h2>');

        if (decoded && decoded.timeline) {
            // Action[1] has cue, fallbackText, pack
            const a1 = decoded.timeline[1];
            assert('cue survives encoding', a1.cue === 'hum-start',
                `Expected "hum-start", got "${a1.cue}"`);
            assert('fallbackText survives encoding', a1.fallbackText === 'Start humming now',
                `Expected "Start humming now", got "${a1.fallbackText}"`);
            assert('pack survives encoding', a1.pack === 'flash-mob-v1',
                `Expected "flash-mob-v1", got "${a1.pack}"`);

            // Action[3] has randomCues
            const a3 = decoded.timeline[3];
            assert('randomCues survives encoding', deepEqual(a3.randomCues, ['harmony-a', 'harmony-b', 'harmony-c']),
                `Expected ["harmony-a","harmony-b","harmony-c"], got ${JSON.stringify(a3.randomCues)}`);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 4: Default values omitted in encoded data
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>4. Default Value Omission</h2>');

        try {
            const defaultEvent = embeddedEventToEvent({
                title: 'Defaults Test',
                startTime: startTime,
                timezone: 'UTC',
                timeline: [makeAction(0, 'Test action')],
            });
            const defaultEncoded = encodeEvent(defaultEvent);
            // Decode the raw JSON to check what's actually in the payload
            const rawData = defaultEncoded.substring(3); // strip v1_
            const rawBase64 = fromUrlSafeBase64(rawData);
            const rawBytes = base64ToBytes(rawBase64);
            const rawJson = new TextDecoder().decode(pako.ungzip(rawBytes));
            const rawObj = JSON.parse(rawJson);

            assert('defaultNoticeSeconds omitted when 5', !('defaultNoticeSeconds' in rawObj),
                `Found defaultNoticeSeconds=${rawObj.defaultNoticeSeconds} in encoded JSON`);
            assert('timeWindowSeconds omitted when 60', !('timeWindowSeconds' in rawObj),
                `Found timeWindowSeconds=${rawObj.timeWindowSeconds} in encoded JSON`);
            assert('visualMode omitted when "circular"', !('visualMode' in rawObj),
                `Found visualMode="${rawObj.visualMode}" in encoded JSON`);

            log(`<pre>Raw encoded JSON (defaults stripped):\n${esc(JSON.stringify(rawObj, null, 2))}</pre>`);
        } catch (e) {
            assert('Default omission test did not throw', false, e.message);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 5: Compression stats
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>5. Compression Stats</h2>');

        try {
            const stats = getCompressionStats(sampleEvent);
            assert('Stats has originalSize', typeof stats.originalSize === 'number' && stats.originalSize > 0);
            assert('Stats has compressedSize', typeof stats.compressedSize === 'number' && stats.compressedSize > 0);
            assert('Compression ratio > 1 (compressed is smaller)', stats.ratio > 1,
                `Ratio was ${stats.ratio.toFixed(2)}`);

            log(`<dl class="stats">
                <dt>Original JSON (bytes):</dt><dd>${stats.originalSize}</dd>
                <dt>Encoded string length:</dt><dd>${stats.compressedSize}</dd>
                <dt>Compression ratio:</dt><dd>${stats.ratio.toFixed(2)}x</dd>
                <dt>URL-safe:</dt><dd>${!/[+/=]/.test(encoded) ? 'Yes' : 'NO'}</dd>
            </dl>`);
        } catch (e) {
            assert('getCompressionStats() did not throw', false, e.message);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 6: URL fragment round-trip
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>6. URL Fragment Round-Trip</h2>');

        try {
            // Set location hash
            const hashData = encoded;
            window.location.hash = hashData;
            const readBack = window.location.hash.substring(1); // strip leading #
            assert('location.hash round-trip preserves data', readBack === hashData,
                `Written: ${hashData.substring(0, 50)}...\nRead: ${readBack.substring(0, 50)}...`);

            // Decode from hash
            const fromHash = decodeEvent(readBack);
            assert('Decode from location.hash works', fromHash.title === sampleEvent.title);

            // Clean up
            history.replaceState(null, '', window.location.pathname);
        } catch (e) {
            assert('URL fragment test did not throw', false, e.message);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 7: Edge cases
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>7. Edge Cases</h2>');

        // Empty description
        try {
            const noDesc = embeddedEventToEvent({
                title: 'No Description',
                startTime: startTime,
                timezone: 'UTC',
                timeline: [makeAction(0, 'Go')],
            });
            const enc = encodeEvent(noDesc);
            const dec = decodeEvent(enc);
            assert('Empty description round-trips', (dec.description ?? '') === '' || dec.description === null);
        } catch (e) {
            assert('Empty description test', false, e.message);
        }

        // Minimal event (1 action)
        try {
            const minimal = embeddedEventToEvent({
                title: 'Min',
                startTime: startTime,
                timezone: 'UTC',
                timeline: [makeAction(0, 'X')],
            });
            const enc = encodeEvent(minimal);
            const dec = decodeEvent(enc);
            assert('Minimal event (1 action) round-trips', dec.title === 'Min' && dec.timeline.length === 1);
            log(`<pre>Minimal encoded length: ${enc.length} chars</pre>`);
        } catch (e) {
            assert('Minimal event test', false, e.message);
        }

        // Unicode text
        try {
            const unicode = embeddedEventToEvent({
                title: 'Flash Mob ğŸµ æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ',
                description: 'Ã‰vÃ©nement avec des caractÃ¨res spÃ©ciaux: Ã Ã©Ã®ÃµÃ¼ Ã± ä¸­æ–‡',
                startTime: startTime,
                timezone: 'Asia/Tokyo',
                timeline: [makeAction(0, 'å¼€å§‹! ğŸ‰ DÃ©but')],
            });
            const enc = encodeEvent(unicode);
            const dec = decodeEvent(enc);
            assert('Unicode title survives', dec.title === 'Flash Mob ğŸµ æ—¥æœ¬èªãƒ†ã‚¹ãƒˆ',
                `Got: "${dec.title}"`);
            assert('Unicode description survives', dec.description === 'Ã‰vÃ©nement avec des caractÃ¨res spÃ©ciaux: Ã Ã©Ã®ÃµÃ¼ Ã± ä¸­æ–‡',
                `Got: "${dec.description}"`);
            assert('Unicode action survives', dec.timeline[0].action === 'å¼€å§‹! ğŸ‰ DÃ©but',
                `Got: "${dec.timeline[0].action}"`);
        } catch (e) {
            assert('Unicode test', false, e.message);
        }

        // Many actions
        try {
            const manyActions = [];
            for (let i = 0; i < 50; i++) {
                manyActions.push(makeAction(i * 10, `Action ${i + 1}`));
            }
            const bigEvent = embeddedEventToEvent({
                title: 'Big Event',
                description: 'An event with 50 actions',
                startTime: startTime,
                timezone: 'UTC',
                timeline: manyActions,
            });
            const enc = encodeEvent(bigEvent);
            const dec = decodeEvent(enc);
            assert('50 actions round-trip', dec.timeline.length === 50);
            const bigStats = getCompressionStats(bigEvent);
            log(`<pre>50-action event: ${bigStats.originalSize} bytes â†’ ${bigStats.compressedSize} chars (${bigStats.ratio.toFixed(2)}x ratio)</pre>`);
        } catch (e) {
            assert('Many actions test', false, e.message);
        }

        // Non-default settings
        try {
            const custom = embeddedEventToEvent({
                title: 'Custom Settings',
                startTime: startTime,
                timezone: 'UTC',
                timeline: [makeAction(0, 'Go')],
                defaultNoticeSeconds: 15,
                timeWindowSeconds: 120,
                visualMode: 'vertical',
            });
            const enc = encodeEvent(custom);
            const dec = decodeEvent(enc);
            assert('Non-default defaultNoticeSeconds survives', dec.defaultNoticeSeconds === 15,
                `Expected 15, got ${dec.defaultNoticeSeconds}`);
            assert('Non-default timeWindowSeconds survives', dec.timeWindowSeconds === 120,
                `Expected 120, got ${dec.timeWindowSeconds}`);
            assert('Non-default visualMode survives', dec.visualMode === 'vertical',
                `Expected "vertical", got "${dec.visualMode}"`);
        } catch (e) {
            assert('Non-default settings test', false, e.message);
        }

        // Invalid data
        try {
            decodeEvent('v1_' + toUrlSafeBase64(btoa('not valid gzip')));
            assert('Invalid gzip throws', false, 'Should have thrown');
        } catch (e) {
            assert('Invalid gzip throws', true);
        }

        // Legacy (no prefix) decoding
        try {
            // Encode, strip prefix, decode
            const legacyEncoded = encoded.substring(3); // strip "v1_"
            const legacyDecoded = decodeEvent(legacyEncoded);
            assert('Legacy (no prefix) decoding works', legacyDecoded.title === sampleEvent.title);
        } catch (e) {
            assert('Legacy decoding test', false, e.message);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 8: embeddedEventToEvent / eventToEmbeddedEvent
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>8. Model Conversion Helpers</h2>');

        try {
            const embedded = {
                title: 'Conversion Test',
                description: 'Testing conversion helpers',
                startTime: startTime,
                timezone: 'America/Chicago',
                timeline: sampleActions,
                defaultNoticeSeconds: 10,
                timeWindowSeconds: 90,
                visualMode: 'vertical',
            };

            const event = embeddedEventToEvent(embedded);
            assert('embeddedEventToEvent: has id', typeof event.id === 'string' && event.id.length > 0);
            assert('embeddedEventToEvent: has endTime', typeof event.endTime === 'string');
            assert('embeddedEventToEvent: status is "published"', event.status === 'published');
            assert('embeddedEventToEvent: creatorId is "embedded"', event.creatorId === 'embedded');
            assert('embeddedEventToEvent: preserves custom defaults', event.defaultNoticeSeconds === 10);
            assert('embeddedEventToEvent: endTime > last action',
                new Date(event.endTime).getTime() > new Date(sampleActions[sampleActions.length - 1].time).getTime());

            const backToEmbedded = eventToEmbeddedEvent(event);
            assert('eventToEmbeddedEvent: title preserved', backToEmbedded.title === 'Conversion Test');
            assert('eventToEmbeddedEvent: non-default notice kept', backToEmbedded.defaultNoticeSeconds === 10);
            assert('eventToEmbeddedEvent: non-default window kept', backToEmbedded.timeWindowSeconds === 90);
            assert('eventToEmbeddedEvent: non-default visualMode kept', backToEmbedded.visualMode === 'vertical');
        } catch (e) {
            assert('Model conversion test', false, e.message);
        }

        // Default stripping
        try {
            const defaultEvent = embeddedEventToEvent({
                title: 'Default Strip Test',
                startTime: startTime,
                timezone: 'UTC',
                timeline: [makeAction(0, 'Go')],
            });
            const stripped = eventToEmbeddedEvent(defaultEvent);
            assert('eventToEmbeddedEvent: default notice stripped to null', stripped.defaultNoticeSeconds === null);
            assert('eventToEmbeddedEvent: default window stripped to null', stripped.timeWindowSeconds === null);
            assert('eventToEmbeddedEvent: default visualMode stripped to null', stripped.visualMode === null);
        } catch (e) {
            assert('Default stripping test', false, e.message);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 9: Text Format Parsing
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>9. Text Format Parsing</h2>');

        // 9.1 Basic text format parse
        try {
            const basicText = [
                'Title: Test Event',
                'Description: A test',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: America/New_York',
                '',
                '0:00  Get ready',
                '0:30  Wave left',
                '1:00  Jump',
            ].join('\n');
            const basicParsed = parseTextFormat(basicText);
            assert('9.1 Basic parse: title', basicParsed.title === 'Test Event');
            assert('9.1 Basic parse: description', basicParsed.description === 'A test');
            assert('9.1 Basic parse: timezone', basicParsed.timezone === 'America/New_York');
            assert('9.1 Basic parse: 3 actions', basicParsed.timeline.length === 3);
            assert('9.1 Basic parse: action text', basicParsed.timeline[0].action === 'Get ready');
            assert('9.1 Basic parse: default style', basicParsed.timeline[0].style === 'normal');
        } catch (e) {
            assert('9.1 Basic text format parse', false, e.message);
        }

        // 9.2 Brackets-before-command (new syntax)
        try {
            const bracketsBefore = [
                'Title: Brackets Before',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '0:30  [emphasis] Wave right',
                '1:00  [alert, countdown, haptic:triple] Jump!',
            ].join('\n');
            const bbParsed = parseTextFormat(bracketsBefore);
            assert('9.2 Brackets before: action text extracted', bbParsed.timeline[0].action === 'Wave right');
            assert('9.2 Brackets before: emphasis style', bbParsed.timeline[0].style === 'emphasis');
            assert('9.2 Brackets before: alert style', bbParsed.timeline[1].style === 'alert');
            assert('9.2 Brackets before: countdown on', deepEqual(bbParsed.timeline[1].countdownSeconds, [5, 4, 3, 2, 1]));
            assert('9.2 Brackets before: haptic:triple', bbParsed.timeline[1].hapticPattern === 'triple');
            assert('9.2 Brackets before: action text clean', bbParsed.timeline[1].action === 'Jump!');
        } catch (e) {
            assert('9.2 Brackets before command', false, e.message);
        }

        // 9.3 Brackets-after-command backward compat
        try {
            const bracketsAfter = [
                'Title: Brackets After',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '0:30  Wave right  [emphasis]',
                '1:00  Jump!  [alert, countdown]',
            ].join('\n');
            // Capture console.warn for deprecation check
            const origWarn = console.warn;
            let warnCalled = false;
            console.warn = function() { warnCalled = true; };
            const baParsed = parseTextFormat(bracketsAfter);
            console.warn = origWarn;
            assert('9.3 Brackets after: still works', baParsed.timeline[0].style === 'emphasis');
            assert('9.3 Brackets after: action text clean', baParsed.timeline[0].action === 'Wave right');
            assert('9.3 Brackets after: countdown works', deepEqual(baParsed.timeline[1].countdownSeconds, [5, 4, 3, 2, 1]));
            assert('9.3 Brackets after: deprecation warning logged', warnCalled === true);
        } catch (e) {
            assert('9.3 Brackets after backward compat', false, e.message);
        }

        // 9.4 New config headers
        try {
            const configHeaders = [
                'Title: Config Headers Test',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                'NotifyWindow: 15',
                'CountdownWindow: 5',
                'Countdown: true',
                'Haptic: countdown',
                '',
                '0:00  Go',
            ].join('\n');
            const chParsed = parseTextFormat(configHeaders);
            const chValidated = validateAndComplete(chParsed);
            assert('9.4 Config: defaultNoticeSeconds = 15', chValidated.defaultNoticeSeconds === 15);
            assert('9.4 Config: defaultCountdownSeconds = 5', chValidated.defaultCountdownSeconds === 5);
            assert('9.4 Config: defaultCountdown = true', chValidated.defaultCountdown === true);
            assert('9.4 Config: defaultHapticMode = countdown', chValidated.defaultHapticMode === 'countdown');
        } catch (e) {
            assert('9.4 New config headers', false, e.message);
        }

        // 9.5 New bracket tags
        try {
            const newTags = [
                'Title: New Tags Test',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '0:00  [notify:10] Action with custom notice',
                '0:30  [countdown:3] Three sec countdown',
                '1:00  [no-notify] Silent action',
                '1:30  [no-countdown] No countdown here',
            ].join('\n');
            const ntParsed = parseTextFormat(newTags);
            // notify:10
            assert('9.5 notify:10: noticeSeconds', ntParsed.timeline[0].noticeSeconds === 10);
            assert('9.5 notify:10: action text', ntParsed.timeline[0].action === 'Action with custom notice');
            // countdown:3
            assert('9.5 countdown:3: array', deepEqual(ntParsed.timeline[1].countdownSeconds, [3, 2, 1]),
                'Expected [3,2,1], got ' + JSON.stringify(ntParsed.timeline[1].countdownSeconds));
            assert('9.5 countdown:3: action text', ntParsed.timeline[1].action === 'Three sec countdown');
            // no-notify
            assert('9.5 no-notify: audioAnnounce false', ntParsed.timeline[2].audioAnnounce === false);
            assert('9.5 no-notify: noticeSeconds 0', ntParsed.timeline[2].noticeSeconds === 0);
            // no-countdown
            assert('9.5 no-countdown: null countdown', ntParsed.timeline[3].countdownSeconds === null);
        } catch (e) {
            assert('9.5 New bracket tags', false, e.message);
        }

        // 9.6 Combined: config header + per-action overrides
        try {
            const combined = [
                'Title: Combined Test',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                'NotifyWindow: 20',
                'Countdown: true',
                '',
                '0:00  [emphasis, notify:10] Custom notice action',
                '0:30  [no-notify, alert] Silent alert',
            ].join('\n');
            const combParsed = parseTextFormat(combined);
            const combValidated = validateAndComplete(combParsed);
            // Event-level config
            assert('9.6 Combined: event defaultNoticeSeconds', combValidated.defaultNoticeSeconds === 20);
            assert('9.6 Combined: event defaultCountdown', combValidated.defaultCountdown === true);
            // Per-action overrides
            assert('9.6 Combined: action notify:10 override', combParsed.timeline[0].noticeSeconds === 10);
            assert('9.6 Combined: action emphasis style', combParsed.timeline[0].style === 'emphasis');
            assert('9.6 Combined: no-notify action', combParsed.timeline[1].audioAnnounce === false);
            assert('9.6 Combined: alert style', combParsed.timeline[1].style === 'alert');
        } catch (e) {
            assert('9.6 Combined config + overrides', false, e.message);
        }

        // 9.7 Edge cases
        try {
            // Empty brackets â€” should not crash, no tags parsed
            const emptyBrackets = [
                'Title: Edge Cases',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '0:00  [] Action with empty brackets',
            ].join('\n');
            // Empty brackets: regex [^\]]+ requires 1+ chars, so [] won't match â€” action text includes []
            const ebParsed = parseTextFormat(emptyBrackets);
            assert('9.7 Empty brackets: no crash', ebParsed.timeline.length === 1);

            // Unknown tags: should warn, not fail
            const unknownTags = [
                'Title: Unknown Tags',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '0:00  [emphasis, bogus] Action here',
            ].join('\n');
            const origWarn2 = console.warn;
            let warnMessages = [];
            console.warn = function(...args) { warnMessages.push(args); };
            const utParsed = parseTextFormat(unknownTags);
            console.warn = origWarn2;
            assert('9.7 Unknown tag: no crash', utParsed.timeline.length === 1);
            assert('9.7 Unknown tag: emphasis still applied', utParsed.timeline[0].style === 'emphasis');
            // Warnings should include the unknown tag
            const warningText = JSON.stringify(warnMessages);
            assert('9.7 Unknown tag: warning generated', warningText.includes('bogus'),
                'Warnings: ' + warningText);

            // Tags with extra whitespace
            const spaceyTags = [
                'Title: Spacey Tags',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '0:00  [ emphasis , countdown ] Action here',
            ].join('\n');
            const stParsed = parseTextFormat(spaceyTags);
            assert('9.7 Spacey tags: emphasis applied', stParsed.timeline[0].style === 'emphasis');
            assert('9.7 Spacey tags: countdown applied', deepEqual(stParsed.timeline[0].countdownSeconds, [5, 4, 3, 2, 1]));
        } catch (e) {
            assert('9.7 Edge cases', false, e.message);
        }

        // 9.8 Round-trip: text format â†’ parse â†’ validate â†’ encode â†’ decode â†’ verify
        try {
            const roundTrip = [
                'Title: Round Trip Test',
                'Description: Testing full pipeline',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: America/Chicago',
                'NotifyWindow: 12',
                'CountdownWindow: 7',
                'Haptic: action',
                '',
                '0:00  [emphasis] Get ready everyone',
                '0:30  [countdown:3, alert] Jump now!',
                '1:00  [no-notify] Silent cue',
            ].join('\n');
            const rtParsed = parseTextFormat(roundTrip);
            const rtValidated = validateAndComplete(rtParsed);
            const rtEncoded = encodeEmbeddedEvent(rtValidated);
            const rtDecoded = decodeEvent(rtEncoded);

            assert('9.8 Round-trip: title survives', rtDecoded.title === 'Round Trip Test');
            assert('9.8 Round-trip: description survives', rtDecoded.description === 'Testing full pipeline');
            assert('9.8 Round-trip: timezone survives', rtDecoded.timezone === 'America/Chicago');
            assert('9.8 Round-trip: 3 actions', rtDecoded.timeline.length === 3);
            assert('9.8 Round-trip: defaultNoticeSeconds', rtDecoded.defaultNoticeSeconds === 12);
            assert('9.8 Round-trip: defaultCountdownSeconds', rtDecoded.defaultCountdownSeconds === 7);
            assert('9.8 Round-trip: defaultHapticMode', rtDecoded.defaultHapticMode === 'action');
            // Action details
            assert('9.8 Round-trip: action[0] emphasis', rtDecoded.timeline[0].style === 'emphasis');
            assert('9.8 Round-trip: action[0] text', rtDecoded.timeline[0].action === 'Get ready everyone');
            assert('9.8 Round-trip: action[1] countdown:3', deepEqual(rtDecoded.timeline[1].countdownSeconds, [3, 2, 1]),
                'Got: ' + JSON.stringify(rtDecoded.timeline[1].countdownSeconds));
            assert('9.8 Round-trip: action[1] alert', rtDecoded.timeline[1].style === 'alert');
            assert('9.8 Round-trip: action[2] no-notify', rtDecoded.timeline[2].audioAnnounce === false);
        } catch (e) {
            assert('9.8 Round-trip', false, e.message);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 10: Briefing Block Parsing
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>10. Briefing Block Parsing</h2>');

        // 10.1 Full briefing with all keys
        try {
            const briefingText = [
                'Title: Briefing Test',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '[BRIEFING]',
                'role: Main group â€” all participants',
                'event: Flash mob at the park',
                'exit: Northeast corner, 5th and Main',
                'exit_coords: 40.7829, -73.9654',
                'rally: Weston Park, near fountain',
                'rally_coords: 40.7845, -73.9632',
                'abort: Open umbrella. Walk to exit. Do not run.',
                'notes: Wear blue shirt',
                '',
                '[TIMELINE]',
                '0:00  Get ready',
                '0:30  Wave left',
            ].join('\n');
            const bParsed = parseTextFormat(briefingText);
            assert('10.1 Briefing: parsed', bParsed.briefing !== null);
            assert('10.1 Briefing: role', bParsed.briefing.role === 'Main group â€” all participants');
            assert('10.1 Briefing: event', bParsed.briefing.event === 'Flash mob at the park');
            assert('10.1 Briefing: exit', bParsed.briefing.exit === 'Northeast corner, 5th and Main');
            assert('10.1 Briefing: exitCoords (snake_case â†’ camelCase)', bParsed.briefing.exitCoords === '40.7829, -73.9654');
            assert('10.1 Briefing: rally', bParsed.briefing.rally === 'Weston Park, near fountain');
            assert('10.1 Briefing: rallyCoords', bParsed.briefing.rallyCoords === '40.7845, -73.9632');
            assert('10.1 Briefing: abort', bParsed.briefing.abort === 'Open umbrella. Walk to exit. Do not run.');
            assert('10.1 Briefing: notes', bParsed.briefing.notes === 'Wear blue shirt');
            assert('10.1 Briefing: title still parsed', bParsed.title === 'Briefing Test');
            assert('10.1 Briefing: timeline actions parsed', bParsed.timeline.length === 2);
            assert('10.1 Briefing: first action text', bParsed.timeline[0].action === 'Get ready');
        } catch (e) {
            assert('10.1 Full briefing', false, e.message);
        }

        // 10.2 No briefing section â€” briefing should be null
        try {
            const noBriefing = [
                'Title: No Briefing',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '0:00  Get ready',
                '0:30  Wave left',
            ].join('\n');
            const nbParsed = parseTextFormat(noBriefing);
            assert('10.2 No briefing: briefing is null', nbParsed.briefing === null);
            assert('10.2 No briefing: timeline still works', nbParsed.timeline.length === 2);
        } catch (e) {
            assert('10.2 No briefing', false, e.message);
        }

        // 10.3 Briefing round-trip through encode/decode
        try {
            const briefingRT = [
                'Title: Briefing Round-Trip',
                'Start: 2026-06-01T14:00:00Z',
                'Timezone: UTC',
                '',
                '[BRIEFING]',
                'role: Group Alpha',
                'exit: South gate',
                'abort: Disperse calmly',
                '',
                '[TIMELINE]',
                '0:00  Stand by',
            ].join('\n');
            const rtParsed = parseTextFormat(briefingRT);
            const rtValidated = validateAndComplete(rtParsed);
            const rtEncoded = encodeEmbeddedEvent(rtValidated);
            const rtDecoded = decodeEvent(rtEncoded);
            assert('10.3 Round-trip: briefing survives encoding', rtDecoded.briefing !== null);
            assert('10.3 Round-trip: role preserved', rtDecoded.briefing.role === 'Group Alpha');
            assert('10.3 Round-trip: exit preserved', rtDecoded.briefing.exit === 'South gate');
            assert('10.3 Round-trip: abort preserved', rtDecoded.briefing.abort === 'Disperse calmly');
            assert('10.3 Round-trip: keys not in briefing are absent', rtDecoded.briefing.rally === undefined);
        } catch (e) {
            assert('10.3 Briefing round-trip', false, e.message);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEST SUITE 11: Encryption (AES-GCM)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        log('<h2>11. Encryption (AES-GCM)</h2>');

        async function runEncryptionTests() {
            // 11.1 Encrypt/decrypt round-trip
            try {
                const password = 'test-password-123';
                const encr = await encodeEventEncrypted(sampleEvent, password);
                const decr = await decodeEventEncrypted(encr, password);
                assert('11.1 Encrypt/decrypt round-trip: title', decr.title === sampleEvent.title,
                    `Expected "${sampleEvent.title}", got "${decr.title}"`);
                assert('11.1 Encrypt/decrypt round-trip: timeline length', decr.timeline.length === sampleEvent.timeline.length);
                assert('11.1 Encrypt/decrypt round-trip: start time', decr.startTime === sampleEvent.startTime);
            } catch (e) {
                assert('11.1 Encrypt/decrypt round-trip', false, e.message);
            }

            // 11.2 Wrong password throws "Wrong password"
            try {
                const encr = await encodeEventEncrypted(sampleEvent, 'correct-password');
                try {
                    await decodeEventEncrypted(encr, 'wrong-password');
                    assert('11.2 Wrong password throws', false, 'Should have thrown');
                } catch (e) {
                    assert('11.2 Wrong password throws "Wrong password"', e.message === 'Wrong password',
                        `Expected "Wrong password", got "${e.message}"`);
                }
            } catch (e) {
                assert('11.2 Wrong password', false, e.message);
            }

            // 11.3 v1e_ prefix
            try {
                const encr = await encodeEventEncrypted(sampleEvent, 'pw');
                assert('11.3 v1e_ prefix', encr.startsWith('v1e_'),
                    `Got prefix: "${encr.substring(0, 10)}..."`);
            } catch (e) {
                assert('11.3 v1e_ prefix', false, e.message);
            }

            // 11.4 Field preservation (cue, pack, briefing, etc.)
            try {
                const withBriefing = embeddedEventToEvent({
                    title: 'Encrypted Briefing Test',
                    startTime: startTime,
                    timezone: 'America/Chicago',
                    timeline: sampleActions,
                    briefing: { role: 'Alpha team', exit: 'North gate', abort: 'Walk away calmly' },
                });
                const encr = await encodeEventEncrypted(withBriefing, 'brief-pw');
                const decr = await decodeEventEncrypted(encr, 'brief-pw');
                assert('11.4 Field preservation: briefing.role', decr.briefing && decr.briefing.role === 'Alpha team',
                    `Got: ${JSON.stringify(decr.briefing)}`);
                assert('11.4 Field preservation: briefing.exit', decr.briefing && decr.briefing.exit === 'North gate');
                assert('11.4 Field preservation: cue survives', decr.timeline[1].cue === 'hum-start',
                    `Got: "${decr.timeline[1].cue}"`);
                assert('11.4 Field preservation: pack survives', decr.timeline[1].pack === 'flash-mob-v1');
                assert('11.4 Field preservation: randomCues', deepEqual(decr.timeline[3].randomCues, ['harmony-a', 'harmony-b', 'harmony-c']));
            } catch (e) {
                assert('11.4 Field preservation', false, e.message);
            }

            // 11.5 Unicode password
            try {
                const uniPw = 'å¯†ç ğŸ”‘ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰';
                const encr = await encodeEventEncrypted(sampleEvent, uniPw);
                const decr = await decodeEventEncrypted(encr, uniPw);
                assert('11.5 Unicode password: round-trip works', decr.title === sampleEvent.title);
            } catch (e) {
                assert('11.5 Unicode password', false, e.message);
            }

            // 11.6 Large event (50 actions)
            try {
                const manyActions = [];
                for (let i = 0; i < 50; i++) {
                    manyActions.push(makeAction(i * 10, `Encrypted Action ${i + 1}`));
                }
                const bigEvent = embeddedEventToEvent({
                    title: 'Big Encrypted Event',
                    description: '50-action encrypted event',
                    startTime: startTime,
                    timezone: 'UTC',
                    timeline: manyActions,
                });
                const encr = await encodeEventEncrypted(bigEvent, 'big-pw');
                const decr = await decodeEventEncrypted(encr, 'big-pw');
                assert('11.6 Large event: 50 actions survive', decr.timeline.length === 50);
                assert('11.6 Large event: title', decr.title === 'Big Encrypted Event');
            } catch (e) {
                assert('11.6 Large event', false, e.message);
            }

            // 11.7 Different passwords produce different output
            try {
                const encA = await encodeEventEncrypted(sampleEvent, 'password-A');
                const encB = await encodeEventEncrypted(sampleEvent, 'password-B');
                assert('11.7 Different passwords â†’ different ciphertext', encA !== encB,
                    'Both encryptions produced identical output');
            } catch (e) {
                assert('11.7 Different passwords', false, e.message);
            }

            // 11.8 ENCRYPTED_EVENT sentinel from parseEventInput
            try {
                const encr = await encodeEventEncrypted(sampleEvent, 'sentinel-test');
                try {
                    parseEventInput(encr);
                    assert('11.8 ENCRYPTED_EVENT sentinel: throws', false, 'Should have thrown');
                } catch (e) {
                    assert('11.8 ENCRYPTED_EVENT sentinel: message', e.message === 'ENCRYPTED_EVENT',
                        `Expected "ENCRYPTED_EVENT", got "${e.message}"`);
                    assert('11.8 ENCRYPTED_EVENT sentinel: has data', e.data === encr,
                        `error.data should be the encrypted string`);
                }
            } catch (e) {
                assert('11.8 ENCRYPTED_EVENT sentinel', false, e.message);
            }
        }

        // Run async encryption tests, then show summary
        runEncryptionTests().then(() => {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SUMMARY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const summaryEl = document.getElementById('summary');
            const total = passed + failed;
            if (failed === 0) {
                summaryEl.className = 'summary pass';
                summaryEl.innerHTML = `<span class="icon"></span>ALL ${total} TESTS PASSED`;
            } else {
                summaryEl.className = 'summary fail';
                summaryEl.innerHTML = `<span class="icon"></span>${failed} of ${total} tests FAILED`;
            }
        }).catch(e => {
            const summaryEl = document.getElementById('summary');
            summaryEl.className = 'summary fail';
            summaryEl.innerHTML = `<span class="icon"></span>Encryption tests crashed: ${esc(e.message)}`;
        });

    })();
    </script>
</body>
</html>
